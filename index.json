[{"categories":["网络"],"content":"因为魔法软件的一些奇奇怪怪的问题，进而怀疑是 HTTP/3 搞得鬼，于是有了这篇文章，算是一个铺垫。 HTTP/3 是超文本传输协议 (HTTP) 的下一个主要版本。于 2021 年发布。 HTTP/3 的主要一个特点是它使用一种新的传输协议 QUIC 来运行。QUIC 旨在提供快速连接，支持迅速切换网络。 Tip 阅读本文可能需要具备了解 TCP / IP 协议、http 请求的整个过程相关基础知识。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:0:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#"},{"categories":["网络"],"content":" 什么是 QUICQUIC（Quick UDP Internet Connections）由 Google 开发的一种基于 UDP 的传输层网络协议，旨在替代传统的 TCP 协议。 它集成了加密（类似 TLS），支持多路复用，可以快速恢复连接。 多路复用（Multiplexing）指的是在同一个连接（比如一个 QUIC 连接）上同时传输多个独立的数据流（streams），每个数据流可以独立发送和接收数据。 早在 HTTP/2 时代就在 TCP 之上实现了应用层的多路复用，但无法解决 TCP 层的队头阻塞。也就是逻辑上独立，但在传输层面共享同一个 TCP 的有序字节流。 在 QUIC 中，每个数据流都有一个唯一的流 ID。发送端将不同流的数据分成多个数据包，每个数据包带有流 ID 和偏移量（offset），接收端根据流 ID 和偏移量将数据重新组装。 这样，多个数据流的数据可以交错发送，而不会互相阻塞，再加上基于 UDP 在传输层彻底解决了队头阻塞问题。 经典的 http/2 模型中，可以简化为 http/2 –\u003e TLS –\u003e TCP –\u003e IP；而到了 QUIC，基本就是保留 HTTP 的基本语义，但把 http/2 + TLS + TCP 的优点整合了起来，因为还得兼容目前的传输层协议（传输层由操作系统内核负责，搞出一个新协议让全球系统都更新那是不现实的），TCP 肯定不行（本来就是为了解决 TCP 的一些问题），那只能选 UDP 了，也就是 QUIC / HTTP/3 –\u003e UDP(作为媒介) –\u003e IP，QUIC 的大部分逻辑都是应用层实现的。 关于快速恢复连接，传统的 TCP 当 IP 发生变化时，例如从 WIFI 切换到数据流量，IP 变化需要重新进行 TCP 握手，到了 QUIC，里面会封装一个连接 ID，只要连接 ID 一样，就可以继续通信，不过这种修改对原有的负载均衡、防火墙等设施会是个不小的挑战，需要针对性做识别或者难以精准识别。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:1:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#什么是-quic"},{"categories":["网络"],"content":" 队头阻塞UDP 本身不保证可靠性，QUIC 在应用层实现了可靠传输机制。 队头阻塞是 TCP 和 HTTP/2 中的一个问题：在一个连接中，如果一个数据包丢失，后续所有数据包都必须等待该丢失包重传完成后才能被处理，导致延迟增加。 因为 TCP 是面向字节流的协议，数据包必须按顺序到达。一个包丢失，后续包即使到达也不能被处理，必须等待丢失包重传。 QUIC 在传输层支持多条独立的数据流，每条流的数据包独立编号。丢包只影响对应流的数据重传，其他流的数据可以继续传输和处理。这样，某个流的丢包不会阻塞其他流，极大减少了延迟。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:1:1","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#队头阻塞"},{"categories":["网络"],"content":" QoS 限制QoS（服务质量）是网络运营商或网络设备用来管理和控制网络流量的一种技术。 通过 QoS，网络可以对不同类型的流量进行分类、优先级排序、带宽限制、延迟控制等。例如，语音通话、视频会议可能被设置为高优先级，网页浏览或文件下载可能被限制带宽。 QoS 机制通常基于协议类型、端口号、IP 地址、流量特征等信息来识别和管理流量。 QUIC 基于 UDP 协议，而 UDP 流量在很多网络环境中被视为“非连接型”或“高风险”流量。 传统网络设备和运营商习惯于对 TCP 流量进行优化和优先处理，而 UDP 流量可能被限制或降速。 QUIC 的加密和多路复用特性使得网络设备难以深度检测（Deep Packet Inspection，DPI）其具体内容和应用类型（防火墙：看不懂？丢了！）。 因此，某些网络运营商或企业网络会对 UDP 流量（包括 QUIC）施加限制，比如： 限制 UDP 流量带宽。 阻断或丢弃 UDP 包。 降低 UDP 流量优先级。 具体表现就是在某些网络环境下，使用 QUIC 的应用（如基于 HTTP/3 的网页访问、Google 服务等）可能会遇到： 连接建立变慢。 传输速度下降。 连接不稳定或频繁重连。 所以，用上了 QUIC 不一定就比 http/2 快，也可能会出现刚开始很快，后面被 QoS 后就丢包严重。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:2:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#qos-限制"},{"categories":["网络"],"content":" 0-RTTRTT（Round-Trip Time，往返时间）是指网络请求从发送端到达接收端并返回发送端所需的时间，通常以毫秒为单位； 而我们常用的 1 RTT (One Round-Trip Time) 代表的是一个数据包从发送方发出，到达接收方，然后接收方发送一个响应数据包，该响应数据包再回到发送方所经历的总时间。 简单来说，它是一个往返时间；我们 ping 的时候看到的 time 其实就是 1 RTT。 传统 TCP + TLS 的握手过程 (通常需要 2-3 RTT)： TCP 握手 (1 RTT): Client -\u003e Server: SYN Server -\u003e Client: SYN-ACK Client -\u003e Server: ACK 到这里，TCP 连接才建立好，耗时 1 RTT。 TLS 1.2 握手 (2 RTT): Client -\u003e Server: ClientHello Server -\u003e Client: ServerHello, Certificate, ServerKeyExchange, ServerHelloDone Client -\u003e Server: ClientKeyExchange, ChangeCipherSpec, Finished Server -\u003e Client: ChangeCipherSpec, Finished TLS 1.2 握手完成，耗时 2 RTT。 TLS 1.3 握手 (1 RTT): Client -\u003e Server: ClientHello Server -\u003e Client: ServerHello, EncryptedExtensions, Certificate, Finished TLS 1.3 握手完成，耗时 1 RTT。 总计： 使用 TLS 1.2: 1 RTT (TCP) + 2 RTT (TLS) = 3 RTT 使用 TLS 1.3: 1 RTT (TCP) + 1 RTT (TLS) = 2 RTT 在最好的情况下，传统的 Web 访问也需要 2 次往返才能开始发送加密的应用数据。 0-RTT 允许客户端在与服务器建立连接时，无需等待任何往返时间 (RTT) 就可以发送应用层数据。这意味着，在某些情况下，客户端可以在发送第一个数据包的同时，就将加密的应用数据发送出去，从而大大减少了连接建立的延迟。 也就是传统的 http/2 时，使用 tls 1.2 至少 3 RTT 才可以传输数据，使用 tls 1.3 至少 2 RTT，但是 QUIC 把 TLS 整合到 http 中，这样就成了 1 RTT（本质逻辑上还是 TCP + TLS，Client Hello 时已经一次性把加密所需要的信息全部传过去），如果之前建立过连接，那么就直接成了 0 RTT。 0-RTT 如何实现？ 0-RTT 的实现依赖于客户端和服务器之间之前已经成功建立过一次 QUIC 连接。 首次连接 (1-RTT)： 客户端和服务器进行完整的 QUIC 握手。 在握手过程中，服务器会向客户端发送一个 会话票据 (Session Ticket) 或 恢复令牌 (Resumption Token)。这个票据包含加密密钥（用于后续 0-RTT 连接）和服务器的传输参数等信息。 客户端将这个会话票据安全地存储起来。 后续连接 (0-RTT)： 当客户端再次尝试连接到同一个服务器时，它会使用之前存储的会话票据中的密钥来预先加密应用层数据。 客户端将这个预加密的应用数据，连同其初始的 QUIC 握手包（包含会话票据），在一个数据包中发送给服务器。 服务器收到这个数据包后，会尝试使用会话票据中的密钥来解密应用数据。 如果解密成功，服务器就可以立即处理这些应用数据，而无需等待客户端的进一步响应。 同时，服务器会完成正常的 QUIC 握手，建立一个具有完美前向保密性 (Perfect Forward Secrecy) 的新会话，用于后续的数据传输。 尽管 0-RTT 带来了巨大的性能提升，但它也引入了一个重要的安全风险：重放攻击 (Replay Attack)。 重放攻击的风险： 由于客户端在服务器完全验证当前会话之前就发送了加密数据，攻击者可以截获这个 0-RTT 数据包，并在稍后将其重新发送给服务器。如果服务器没有适当的机制来检测和阻止重放，它可能会多次执行相同的操作（例如，重复处理一个订单，或者重复发送一个消息）。 QUIC 的常见缓解措施： 服务器端重放检测： 服务器必须跟踪它已经处理过的 0-RTT 会话票据或令牌，以拒绝重复的 0-RTT 数据包。 限制 0-RTT 数据： 建议只在 0-RTT 中发送幂等 (Idempotent) 的请求（例如，HTTP GET 请求）。对于非幂等操作（例如，HTTP POST 请求，创建订单），应避免在 0-RTT 中发送，或者服务器必须有严格的去重机制。 有限的密钥寿命： 0-RTT 使用的密钥具有较短的有效期，以限制潜在的攻击窗口。 不提供完美前向保密性： 0-RTT 数据本身不提供完美前向保密性。如果用于加密 0-RTT 数据的密钥被泄露，那么所有使用该密钥的 0-RTT 数据都可能被解密。然而，一旦 1-RTT 握手完成，后续的数据传输将使用新的密钥，并提供完美前向保密性。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:3:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#0-rtt"},{"categories":["网络"],"content":" DNSDNS 是做什么的就不介绍了，它在网络中的地位一直是非常重要的，基于 DNS 的攻击也没停止过，也是泄露隐私的关键之一，要不然也不至于发展出现在的 DoH、DoT。 对于这部分，关注的问题主要是 DNS 污染和 DNS 劫持，这俩是什么东西我在八年前就写过一个简短的笔记 现在也对这俩有了一些新认识，DNS 污染可能主要还是因为合规问题，国内的 DNS 基本都存在，别管用什么 DoH，都一样，只是说第三方的 DNS 污染的要少一些，运营商会更激进，尤其是移动。毕竟这种效果好成本低，比 DPI 可要省时省力省心。 DNS 劫持一般只发生在运营商默认的 DNS，除了是为了给你套广告来获益（也有一部分是投放木马），另一种就是因为跨网跨省结算，ISP 可能会缓存一些网页，访问的时候给你看缓存的网页以此来节省流量，这个从反馈来说也是移动之前干的多，目前整体看很少。 我们都知道 DNS 是明文，并且还是 UDP，篡改或者监控起来很容易，为了解决这个问题，于是有了 DoH（DNS over HTTPS）和 DoT（DNS over TLS），它们都是用于加密 DNS 查询以提高隐私和安全性的技术，它们的主要区别在于封装方式： DoH 将 DNS 查询封装在 HTTPS 流量中，使用端口 443，使其与普通网页流量难以区分； DoT 使用专用 TLS 连接，在专用端口 853 上传输，虽然更易被网络管理员识别和阻断，但能直接提供 DNS 隐私保护。 还有一个不常用的是 DoH3，它是 DNS over HTTP/3 的简称，它是一种基于 HTTP/3 和QUIC 协议的加密 DNS（域名系统）解析方法，国内基本不可用，一个是 UDP 的问题一个是支持的公共 DNS 很少。 目前来看，DoH 更普及一些，虽然使用国外的 DoH 能获得更准确的结果，但是一来速度慢，一个是 CDN 效果会很差，因为 CDN 目前还是比较依赖 DNS 解析的。 Warning 这里还要提醒下，任何在国内公网搭建私有 DNS 都是违法的，真要自建，局域网搭建一个就行了或者买台国外的 VPS，切记不要在国内 VPS 上搭建，搞不好会被请喝茶。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:4:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#dns"},{"categories":["网络"],"content":" SNI 阻断既然都说到这里了，那不如也把 SNI 阻断也一起说了吧，这也是常见的一种污染策略； 和 DNS 一样，它也是明文传输，也存在隐私泄露问题，它本意是为了解决一个服务器部署了多个网站，用来确定客户端访问的是那个网站的，以此在建立 TLS 时传递对应的证书。 所以即使使用 https，中间人看不到你的数据内容，但是你访问了什么网站还是知道的，但是话又说回来，部分魔法协议也利用了这个特点，进行域前置，让防火墙误判从而逃过封杀，这个就不展开说了，效果也不是很稳定。 既然可以看到访问的域名，那么就可以针对性的进行阻断，这就是防火墙的 SNI 阻断功能，同样是性价比超高的方案。 为了解决 SNI 隐私泄露的问题，也诞生了一些技术： ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:5:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#sni-阻断"},{"categories":["网络"],"content":" ESNI很显然就是加密 SNI，它需要依赖 DNS，在 DNS 查询阶段就发送对应域名的证书/公钥，然后使用证书加密 SNI。这里的 DNS 也需要 DoH 来保证安全。 缺点就是它只加密 SNI，其实其他一些信息也又隐私泄露的问题，并且如果证书变更，DNS 也未必会及时更新。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:5:1","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#esni"},{"categories":["网络"],"content":" ECHEncrypted Client Hello，即加密整个 ServerHello，它同样使用 DoH 进行公钥分发，不过进行了改进，如果解密失败 ECH 服务器会重新给客户端一份公钥进行重试。 但是目前支持的网站并不多，它还是算非常新的技术。测试网站 PS：Mihomo 的配置中可以开启相关实验性选项 不过话说回来，如果真使用了 http/3 那么也不需要这些东西了，毕竟 QUIC 本身就是全加密的。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:5:2","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#ech"},{"categories":["网络"],"content":" WebRTCWebRTC 的全称是 Web Real-Time Communication，即 网页即时通信。 简单来说，它是一项开源技术，允许网页浏览器和移动应用之间，无需安装任何插件或软件，就能直接进行实时音视频通话和数据交换。 它解决一个核心问题：如何在 Web 上简单、高效地实现实时的点对点（Peer-to-Peer, P2P）通信。 无插件化 (Plugin-Free)：这是它最大的革命性之处。在 WebRTC 出现之前，要在浏览器里实现视频通话，通常需要依赖 Flash、Silverlight 或其他第三方插件，用户体验差且有安全风险。WebRTC 是 W3C 和 IETF 的官方标准，内嵌在主流浏览器（Chrome, Firefox, Safari, Edge）中，开发者可以直接通过 JavaScript API 调用。 实时性 (Real-Time)：专为低延迟通信设计。它使用 UDP 协议作为主要传输方式，最大限度地减少数据传输的延迟，这对于音视频通话、在线游戏等场景至关重要。 点对点通信 (Peer-to-Peer, P2P)：在理想情况下，两个用户的浏览器一旦建立连接，音视频数据流会直接在它们之间传输，不经过服务器中转。这大大降低了服务器的带宽成本和负载，也进一步减少了延迟。参考 NAT 穿透，使用的 ICE 框架本质也是 STUN （打洞） 和 TURN（中转） 安全性高 (Secure)：WebRTC 强制要求所有数据流都必须加密。它使用 SRTP (Secure Real-time Transport Protocol) 协议对音视频数据进行加密，使用 DTLS (Datagram Transport Layer Security) 对数据通道进行加密，确保了通信过程的私密性和安全性。 开源免费：由 Google 开源，并由各大浏览器厂商共同推进，任何人都可以免费使用它来构建应用。 记得之前在 GitHub 看到过一个挺火的基于 WebRTC 的项目，记不清是做远程控制还是类似 OBS 的直播来，确实是不错的场景。 如果你使用魔法软件，并且在意 DNS 泄露，那么 QUIC 和 WebRTC 都应该禁用。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:6:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#webrtc"},{"categories":["网络"],"content":" 目前现况可以查看 cloudflare 提供的实时概览界面：AdoptionAndUsage 目前 Cloudflare 和 Google 是主要的 QUIC / HTTP3 的推动者，例如 Chrome 就会积极的尝试使用 http/3，如果网站不支持或者当前环境不理想，基本都支持自动回退到 http/2。 但是由于国内复杂的网络环境，以及 ISP 对 QUIC 不太积极，加上刚结束优惠期，进入跨网结算，以及蠕虫病毒历史原因等，UDP 本来就被限制的非常严重，尤其是网络高峰期 + 跨省 + 跨网，有老哥直接测出百度都丢包 20%。 如果使用的是魔法软件，那么可能更雪上加霜，原因后面我会单独写在介绍魔法软件配置的博文中。 ","date":"2025-09-06","objectID":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/:7:0","series":null,"tags":["QUIC","DNS","QoS","SNI"],"title":"基于UDP的新世界：QUIC、DNS、WebRTC","uri":"/%E5%9F%BA%E4%BA%8Eudp%E7%9A%84%E6%96%B0%E4%B8%96%E7%95%8Cquicdnswebrtc/#目前现况"},{"categories":["运行日志"],"content":"Cloudflare 不愧是互联网的赛博菩萨，看了下免费用了它家好多服务，用起来也是非常舒服，但是也只是它全部功能的一小部分，开个文章整理下，以防后面忘记怎么用…. 目前我的域名也在 Cloudflare 续费了，除开其他家第一年的优惠，Cloudflare 续费稳定的价格是真的很有性价比。 其实 Github 上有人整理过，并且 Star 非常高：Awesome Cloudflare 但是这么多我也不可能全部都用到，所以整理下我实际用的功能。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:0:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#"},{"categories":["运行日志"],"content":" DNS 管理最基础的功能，这个没什么好说的，最特色的就是橙色云朵，开启代理后把自己的服务隐藏在 Cloudflare 后面可以避免很多麻烦的不安全的东西，缺点就是速度对大陆用户不太友好。 Cloudflare 提供的 API 对于实现 DDNS 也非常的友好，目前我在使用 ddns-go 来使用 DDNS。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:1:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#dns-管理"},{"categories":["运行日志"],"content":" SSL/TLS 选择 Cloudflare 如何加密访问者与 Cloudflare 之间以及 Cloudflare 与源服务器之间的流量，以阻止数据盗窃和其他篡改行为。 则其中最重要的就是选择什么加密模式，当开启了橙色小云，那么我们的服务会隐藏在 Cloudflare 后面，这同时也省去了麻烦的 SSL 证书问题，这样用户可以直接使用 HTTPS 访问我们的服务，毕竟有些是强制 HTTPS 的（HSTS），浏览器也会对 HTTP 进行警告。 Cloudflare 用于连接到您的源服务器的加密模式： 严格（仅 SSL 源服务器拉取） 在 Cloudflare 与您的源服务器之间强制进行加密。使用此模式可以确保与您的源服务器的连接始终是加密的，不考虑您的访问者的请求。 完全（严格） 启用端到端加密，对源服务器证书强制执行验证。使用 Cloudflare 的源服务器 CA 为您的源服务器生成证书（可以通过 Cloudflare 给你生成一个超长时间的证书）。 完全 启用加密端到端。当您的源服务器支持 SSL 认证但未使用有效的公开可信的证书时，使用此模式。 灵活 仅在访问者与 Cloudflare 之间启用加密。这可以避免浏览器发出安全警告，但 Cloudflare 与您的源服务器之间的所有连接均通过 HTTP 建立。 关闭（不安全） 未应用加密。关闭 SSL 将禁用 HTTPS，浏览器同时会显示警告，指出您的网站不安全。 端口问题 使用 Cloudflare 进行代理后，Cloudflare 对服务访问端口有限制，当时我也踩坑搞了好久； 我用 Docker 跑了两个服务，一个映射在 8443 端口仅支持 https；另一个跑在 8002 端口使用了普通的 http，不支持 SSL。 配置好 DNS 后，开始使用域名以 https 访问 8443 端口发现超时；然后访问 8002 时也超时； 当使用灵活模式时，无论你使用 http 还是 https 访问，CF 都会以 http 的方式访问源站，此时源服务器不需要 SSL 证书； 使用完全模式时，会使用访问者请求的方案连接到源。也就是如果访问者使用 http，则 Cloudflare 使用 http 连接到源，https 亦然。 这种模式不会校验源站的 SSL 证书，所以可以使用自签的证书或者 CF 签发的证书。 我当时配置的是灵活模式，根据描述会以 http 的方式访问源站，那确实不会通，但是无法解释 https 访问 8002 为何会超时； 最后我在官方文档的灵活模式解释部分找到了原因： Flexible mode is only supported for HTTPS connections on port 443 (default port). Other ports using HTTPS will fall back to Full mode. https://developers.cloudflare.com/ssl/origin-configuration/ssl-modes/flexible/#limitations 也就是灵活模式这种方式有一个限制，就是仅支持 443 端口的 https 连接，如果使用了其他端口会回退到 Full 完全模式。 也就是如果想用 CF 的 https，就不要自定义端口，把服务端口从 8002 切换到 80 后确实正常了。 改为完全模式后，测试 8443 可以正常访问了，但是 8002 我还是想通过 https 访问，于是我通过 Nginx 做了一个支持，让 8002 支持 https，但是访问依然超时。 现在的情况就有点棘手： Cloudflare 当前处于 Full 模式，使用 https 访问的情况下，8443 正常；8002 超时； 这两个服务都支持了 SSL，通过 IP 访问都正常； 后来都快放弃了，决定翻翻 Cloudflare 的文档（当时用 LLM 问，都是瞎说，浪费了不少时间），最终发现文档有这么一篇： HTTP ports supported by Cloudflare 80 8080 8880 2052 2082 2086 2095 HTTPS ports supported by Cloudflare 443 2053 2083 2087 2096 8443 Network ports 看到这我也是挺无语的，就那么凑巧碰到了 8443 这个白名单。。。。 那既然有端口限制，那估计没戏了，但是！可以通过规则里 Origin Rules 来进行端口重写，实现曲线救国！ 原文我发布在这里了：Cloudflare 代理后访问超时 由于一个域名只能配置一种加密类型（或者通过 Configuration Rules 来实现精细控制），所以我觉得应该至少有两个域名才能比较舒服，一个配置灵活，一个配置完全/完全（严格）；差不多就可以应对所有场景了。 还可以在设置中进行更多的例如 HSTS、TLS 版本、HTTPS 重写等配置。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:2:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#ssltls"},{"categories":["运行日志"],"content":" 规则 修改 HTTP 请求和响应，执行 URL 重定向，配置 Cloudflare 设置，以及触发匹配请求的操作。 规则按照从第一个到最后一个的顺序进行评估和执行。如果有多个规则进行同一项修改，最后执行的规则有效。 我比较常用的规则有重定向规则、URL 重写、Origin Rules，非常实用的功能； 例如 301 / 302 重定向规则，这个在国内的 DNS 平台好像需要备案才能用，301 永久重定向浏览器 URL 会刷新，302 临时重定向地址栏 URL 不会变。 Origin Rules 这个规则可真是非常好用，尤其是如果服务部署在家里或者一些不能使用 80 / 443 端口的机器上，可以通过 Origin Rules 匹配对应的主机域名进行重写端口，这样访问的时候就不需要输那烦人的端口啦！ ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:3:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#规则"},{"categories":["运行日志"],"content":" Workers 和 PagesWorkers 和 Pages 我感觉非常像，CF 中也是放在一个管理里面，Pages 感觉更倾向于放静态资源，不涉及计算逻辑的那种，Workers 则是有一定的处理逻辑，例如对请求进行一些个性化处理。 Workers 最初是拓展 CDN 的一种方式，后来成为高度可配置的通用计算平台。 Pages 最初是静态 web 托管，后来拓展到 Jamstack 领域。 渐渐地，Pages 开始拥有更多 Workers 的强大计算功能，而 Workers 也开始加入 Pages 丰富的开发者功能。 所以，这两项产品的界限变得模糊，让用户很难辨别其中的差别，从而很难根据自己的应用程序需求来选择正确的产品。 我们将努力实现对 Pages 和 Workers 合二为一，同时将产品、工程和设计团队进行融合，而不仅仅是融合产品本身。 我在 Pages 就是放了几个静态页面做门户，或者仍几个 LLM 的 WebUI，都是很简单逻辑的界面，有很多项目都是同时提供 Worker 和 Pages 两种部署方式，所以我感觉可能也总体上差不太多，但是 Pages 在国内的网络环境下可能会更难。 Workers 可以看作是个 Serverless / 边缘计算平台，在 Cloudflare 的全球网络上构建无服务器函数和应用，无需配置或维护基础设施。 Worker 既可以在线编辑运行的 JS 代码，也可以使用官方提供的 CLI 工具（wrangler，更加灵活，支持更全面）进行部署。 一般来说，Worker 都是和 K-V 数据库搭配使用的，毕竟即使无服务应用，完全不存储数据的服务也很少。 目前有大量开源的 Worker 项目，我部署了图床、笔记服务，还有一些乱七八糟例如订阅转换，TG Bot 之类。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:4:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#workers-和-pages"},{"categories":["运行日志"],"content":" Tunnels 和 Access现在 Tunnels 合并到 Zero Trust 里了，Zero Trust 里有很多功能，但是目前我也就是只用到了 Tunnels。 Tunnel 可以做什么？简单理解就是一种内网穿透，把内网的服务发布到公网上，但是相比一般的内网穿透，限制比较多，一般就是用作 Web 服务。 优点是不需要公网云服务器，同时自带域名解析，无需 DDNS 和公网 IP。当然就是国内的速度也就那样，算是勉强能用。 按照 Web 界面，创建一个隧道，一步步按照 Cloudflare 的提示走即可。 QUIC 问题 Tunnels 默认会尝试使用 QUIC，都知道经典的我大*自有国情在此，所以这玩意可不兴开啊，所以启动的时候建议强制使用 http2, 以防出现各种奇奇怪怪的问题。 sh cloudflared tunnel run --protocol http2 如果选择使用的是命令行，关闭命令：sudo systemctl stop cloudflared 另外我再推荐一个 DockFlare 项目，来管理我们的 Tunnels。它可以根据 Docker 的标签自动映射 Tunnels，对于服务比较多的很合适。 准备好一个配置文件，按照文档新建一个自定义 API 密钥，和账户 ID 一起填进去。 properties # === REQUIRED CLOUDFLARE CREDENTIALS === CF_API_TOKEN=vJWdiP9N_e9Ow6Ebqiwi3xC4m0ZX_ESz26Hy5GiS CF_ACCOUNT_ID=9390330d72b32cb9cc413b3db2e6a7b0 CF_ZONE_ID=0bf4bdb5562cf4b89d69a751969a5beb # === TUNNEL CONFIGURATION === TUNNEL_NAME=DockFlare-Tunnel CLOUDFLARED_NETWORK_NAME=cloudflare-net 然后使用使用 docker-compose 启动服务： yml version: '3.8' services: dockflare: image: alplat/dockflare:stable # Or :unstable for the latest features container_name: dockflare restart: unless-stopped ports: - \"5000:5000\" env_file: - .env environment: - STATE_FILE_PATH=/app/data/state.json - TZ=Asia/Shanghai # Set your timezone volumes: - /var/run/docker.sock:/var/run/docker.sock:ro - dockflare_data:/app/data networks: - cloudflare-net # Optional labels to expose DockFlare itself via DockFlare # labels: # - \"dockflare.enable=true\" # - \"dockflare.hostname=dockflare.yourdomain.tld\" # - \"dockflare.service=http://dockflare:5000\" # - \"dockflare.access.policy=authenticate\" # Example: require login volumes: dockflare_data: networks: cloudflare-net: name: cloudflare-net 如果你像我一样使用 Portainer 部署，那么 env 的引用记得改为 stack.env 才能正确引用。 之后对需要穿透的服务打上标签，加入到 cloudflare-net 网络即可 yml labels: - \"dockflare.enable=true\" - \"dockflare.hostname=my-app.example.com\" - \"dockflare.service=http://my-app-name:80\" 同时，DockFlare 的管理页面也可以进行简单的权限控制，还是很方便的。 有些服务不方便给所有人看到，可以建一个认证界面，就是 Zero Trust 的 Access 功能，进入 Access 选择应用程序，选择一个自托管类型，根据服务的域名创建一个验证模式即可，例如输入邮箱发送验证码的方式。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:5:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#tunnels-和-access"},{"categories":["运行日志"],"content":" R2 对象存储官方表示这是分布式对象存储，也就是可以作为静态资源 CDN 使用，尤其是图床场景，许多对象存储的服务商都提供了「免费」的额度，看起来很爽，但是万一被刷之后面对高额的账单就很不爽了： R2 是 Cloudflare 推出的对象存储服务，主打零出口费用（也就是免流量费）和与 Amazon S3 兼容的 API，适合存储大量数据且需频繁访问的场景，完美解决传统图床的痛点。 读取操作（例如下载请求） 1000 万次/月免费，超限后仅 $0.36/千万次 改变操作（例如上传）100 万次 / 月，超出 4.50 美元 / 百万次 存储免费 10 GB / 月，超出后 0.015 美元 / GB 存储 出口流量全免 很多人配合 Workers 使用实现免服务器实现某些服务，例如图床，我使用 CloudFlare-ImgBed 部署了一个图床服务。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:6:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#r2-对象存储"},{"categories":["运行日志"],"content":" AI Gateway Cloudflare AI Gateway 为你的 AI 应用提供集中管理和控制。只需一行代码即可连接您的应用，监控使用情况、成本和错误。通过缓存、速率限制、请求重试和模型回退来降低风险和成本。轻松确保可靠性、可扩展性和生产力。 既然叫网关，那就会有传统网关的一些功能，例如：监控，日志，限速，反向代理，请求或响应改写，集成用户系统等。这些功能其实和 AI 关系不大就是把 LLM 的 API 当成了一个普通的 API 进行接入。 针对 AI 进行的特殊优化： 例如限速功能增加基于 Token 的限速，缓存功能增加基于 Prompt 的缓存，防火墙基于 prompt 和 LLM 返回进行过滤，多个 LLM API Key 之间的负载均衡，多个 LLM Provider 的 API 转换。 这些功能在原有的 API 网关就存在类似的概念，不过在 AI 场景下又有了相应的扩展。 Cloudflare 的这款 AI Gateway 主要功能其实就是一个反向代理。 如果你原来用的是 OpenAI 的 API 那么现在你要做的就是把 SDK 里的 baseURL 换成 https://gateway.ai.cloudflare.com/v1/${accountId}/${gatewayId}/openai 就可以了。 在这个过程中由于流量进出都是过 Cloudflare 的，Cloudflare 平台上就可以提供对应的监控，日志，缓存等功能。 我最初的目的是借助 Cloudflare 的全球网络可以一定程度隐藏掉源 IP，实现对于一些 OpenAI API 访问受限的区域用这个可以绕过去；但是后面发现有点不对，不知道是不是因为 OpenAI 也是用的 CF 的原因还是 Gateway 转发的时候会携带原始请求的一些信息，导致还是会被 OpenAI 封，后面就弃用了。 ","date":"2025-08-31","objectID":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/:7:0","series":null,"tags":["Cloudflare","Tunnels","基础设施"],"title":"我的 Cloudflare 食用手册","uri":"/%E6%88%91%E7%9A%84cloudflare%E9%A3%9F%E7%94%A8%E6%89%8B%E5%86%8C/#ai-gateway"},{"categories":["网络"],"content":"Tailscale 是一种基于 WireGuard 的虚拟组网工具，简单说就是把异地的设备连接成同一个局域网，让我出门后也能像在家里一样访问我的局域网服务； 最开始是想用 docker 来部署，但是回头一想，直接创建个 CT 容器在 Linux 环境下安装不是更好吗？ ZeroTier 也尝试过，纯是感觉不如 Tailscale 的 Web 管理界面好看，以及 ZeroTier 国内应该无法直连访问了。 Tailscale 是基于 WireGuard 做的，如果纯手撸 WireGuard 的话倒是也可以。 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:0:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#"},{"categories":["网络"],"content":" 创建 CT / LXC 环境使用 debian 模板创建一个 LXC 虚拟环境，保持非特权容器默认配置即可；防火墙肯定要关掉，其他的配置看着选就行；像我这种轻度使用 5G 硬盘，512 内存也够了。 因为 Tailscale 是基于 WireGuard 的，所以我们需要配置 LXC 在 Linux 容器中启用 TUN / TAP 网络设备。 sh # 容器内执行查看主机设备信息 ls -al /dev/net/tun *** root root 10, 200 *** /dev/net/tun # 修改CT配置，PVE 主机内执行 vim /etc/pve/lxc/\u003cID\u003e.conf # 修改下面两个，10:200 和上面的要对应起来 # lxc.cgroup2.devices.allow: c 10:200 rwm # lxc.mount.entry: /dev/net/tun dev/net/tun none bind,create=file 下一步就是开启 IP 转发，在 LXC 容器中执行： sh vim /etc/sysctl.conf # 添加以下配置 # net.ipv4.ip_forward = 1 # net.ipv6.conf.all.forwarding = 1 # 或者执行 # echo 'net.ipv4.ip_forward = 1' | sudo tee -a /etc/sysctl.conf # echo 'net.ipv6.conf.all.forwarding = 1' | sudo tee -a /etc/sysctl.conf # 使其生效 sysctl -p /etc/sysctl.conf 作用是可以作为 exit node 使用和开启子网路由功能，exit node 在客户端中选择出口节点就可以了，这样我们访问任何服务都会通过这个 exit node 来代理访问，有点像代理服务器。 启动命令设置子网路由 advertise-routes，作用就是只要连上 Tailscale 的客户端，可以像在家一样访问局域网 IP，不需要使用 Tailscale 虚拟的 LAN IP； 子网路由的最大作用就是只需要有一台设备运行 Tailscale（也就是我配置的这个 LXC 容器），就可以访问整个子网中的任何服务，不需要每个设备/服务都运行一个 Tailscale 来组建虚拟 LAN。 比如我家里路由器配置的 LAN 是 192.168.6.1 网段，设置 exit node 后，随便一台客户端连上，就可以直接使用 192.168.6.x 来访问家里局域网的设备，不需要再额外记 Tailscale 的虚拟 IP 段了，原理自然就是通过我们的这台 LXC 进行数据转发。 PS. 通过这种方式可以实现 Site-to-Site。 另外，如果不配置 UDP GRO 转发，Tailscale 启动的时候可能会有个提示： Warning: UDP GRO forwarding is suboptimally configured on eth0, UDP forwarding throughput capability will increase with a configuration change. See https://tailscale.com/s/ethtool-config-udp-gro 实际上就是让你执行下面的命令来提高性能： sh apt install ethtool apt install networkd-dispatcher # 临时生效，重启后失效 NETDEV=$(ip -o route get 8.8.8.8 | cut -f 5 -d \" \") ethtool -K $NETDEV rx-udp-gro-forwarding on rx-gro-list off # 配置开机自动执行，依赖 networkd-dispatcher # 检查：systemctl is-enabled networkd-dispatcher printf '#!/bin/sh\\n\\nethtool -K %s rx-udp-gro-forwarding on rx-gro-list off \\n' \"$(ip -o route get 8.8.8.8 | cut -f 5 -d \" \")\" | tee /etc/networkd-dispatcher/routable.d/50-tailscale chmod 755 /etc/networkd-dispatcher/routable.d/50-tailscale # 测试效果 /etc/networkd-dispatcher/routable.d/50-tailscale test $? -eq 0 || echo 'An error occurred.' 然后我还看到网友给出了另外一种实现方式，如果使用不了 networkd-dispatcher 那可以尝试一下，我使用的是上面官方的命令。 sh # 查看 UDP 转发及开启 UDP GRO转发 ethtool -k eth0 | grep -e rx-gro-list -e rx-udp-gro-forwarding ethtool -K eth0 rx-udp-gro-forwarding on # 配置开机自动开启 UDP GRO 转发 # vim /etc/systemd/system/ethtool-config.service [Unit] Description=Apply ethtool settings [Service] Type=oneshot ExecStart=/usr/sbin/ethtool -K eth0 rx-udp-gro-forwarding on RemainAfterExit=yes [Install] WantedBy=multi-user.target # 启动服务 systemctl enable --now ethtool-config 根据 AI 的分析，他们作用是一样的，实现方式不一样，一个是事件驱动（网络接口状态变化时触发），一个是服务驱动（系统启动时执行）。 使用服务驱动就需要硬编码网卡接口了，但是可能更好理解一点。 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:1:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#创建-ct--lxc-环境"},{"categories":["网络"],"content":" 安装 Tailscale详细介绍参考官方文档，Linux 下可以使用一键脚本也可以使用包管理，我这里直接使用官方提供的脚本了。 sh # 安装 curl -fsSL https://tailscale.com/install.sh | sh # 安装基础软件包 apt install ethtool net-tools chrony -y vim /etc/systemd/system/tailscale.service # 可以使用 --hostname 指定 hostname [Unit] Description=AutoStart tailscale After=tailscale.service Requires=tailscale.service [Service] Type=oneshot ExecStart=/usr/bin/tailscale up --authkey=xxxx --accept-routes --accept-dns=false --advertise-exit-node --advertise-routes=192.168.6.0/24 ExecStop=/usr/bin/tailscale down RemainAfterExit=yes Restart=on-failure [Install] WantedBy=multi-user.target # 设置自动升级 tailscale set --auto-update # 测试使用 exit node sudo tailscale set --advertise-exit-node 这里认证可以使用默认的 URL 登录，或者在官方 Web 管理台创建一个认证密钥，不过可惜的是好像没有永久有效的，最多也就 90 天，90 天后需要换新的 token； 关于登录有效期 中间机器重启过，导致 Tailscaled 掉了我都不知道。。。。用的时候发现连不上，尴尬。 这次我本打算使用 web 方式登录看看有效期有多久，发现只要登录过 Session 是一直有效的，再次可以不使用 authkey 直接完成登录，那我就测试下不用 authkey 的话是不是可以一直保持，毕竟后台已经禁用过期了。 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:2:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#安装-tailscale"},{"categories":["网络"],"content":" 开始使用 Tailscaled启动 Tailscaled 非常简单，完成上述的安装后，只需要执行 tailscale up 就可以启动，但是我们可能需要进行一些个性化设置。 tailscale 默认会使用自带的 DNS 设置，也就是 Web 管理台上 DNS 哪一个选项卡里的配置，有一个主要的作用就是配置自定义域名来便捷访问服务，这样就不需要记 tailscale 分配的需要 LAN IP 了，但是如果启用了子网路由后，这一个就显得不是特别重要了，可以使用 --accept-dns=false 来禁用。 一切就绪后可以使用下面的命令来检测运行状态： sh # 手动运行，可以不使用 authkey 使用 url 进行登录 tailscale up --authkey=xxxx --accept-routes --accept-dns=false --advertise-exit-node --advertise-routes=192.168.6.0/24 tailscale netcheck tailscale status Tailscale ping xxx # stop tailscale down App 中点击设备右上角也可以查看网络连接类型和质量。 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:3:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#开始使用-tailscaled"},{"categories":["网络"],"content":" 自建 derp目前我的网络环境使用 Tailscaled 的官方服务器是可以正常连通的，当遇到极端的网络环境 UDP 打洞失败，需要走服务器转发的方式的时候，官方的服务器的体验并不是那么好，毕竟原因我们都懂。 如果体验不好，可以使用一些商用的 derp 服务器，例如微林就提供 derp 服务器，如果自己有闲置的服务器也可以自己搭建。 我目前可以正常打洞成功，暂时还用不到，但还是记录一下。 DERP 是用 Go 写的，所以安装 DERP 需要先配置 Go 编译环境。 准备工作，需要放行需要的端口，80 (HTTP)，443 (HTTPS), 3478 (UDP，用于 STUN)。 sh # 安装 Go # 如果你的服务器在境内，可以为Go配置代理加速 # go env -w GOPROXY=https://goproxy.cn,direct wget https://go.dev/dl/go1.25.0.linux-amd64.tar.gz rm -rf /usr/local/go \u0026\u0026 tar -C /usr/local -xzf go1.25.0.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin go version # 安装 derp go install tailscale.com/cmd/derper@main # derper 命令在~/go/bin 下，可以直接拷到任意目录 # sudo cp ~/go/bin/derper /usr/bin/ # 启动 sudo derper --hostname=example.com # or 加入验证 sudo derper --hostname=derp.example.com --verify-clients 其他的也有使用 Docker 来完成部署 DERP 的，类似的作者也有很多，这里就不再细说了。 tailscale 走的 SSL 加密，主要是为了加密代理数据，所以我们其实可以自签一个 SSL 证书，hostname 直接使用 IP，让人如果有 SSL 的域名那更好了。 sh # 修改自己的 IP DERP_IP=\"12.12.12.12\" openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes -keyout ${DERP_IP}.key -out ${DERP_IP}.crt -subj \"/CN=${DERP_IP}\" -addext \"subjectAltName=IP:${DERP_IP}\" derper --hostname=\"12.12.12.12\" -certmode manual -certdir ./ 搭建完成后，在管理页面的 Access Controls 中，新增或者修改规则，最后加入： json { // ... other parts of tailnet policy file \"derpMap\": { \"OmitDefaultRegions\": true, \"Regions\": { \"900\": { \"RegionID\": 900, \"RegionCode\": \"myderp\", \"Nodes\": [ { \"Name\": \"1\", \"RegionID\": 900, \"HostName\": \"example.com\", // IPv4 and IPv6 are optional, but recommended, to reduce // potential DERP connectivity issues if DNS is unavailable // or having issues. Addresses must be publicly routable // and not in private IP ranges. \"IPv4\": \"203.0.113.15\", \"IPv6\": \"2001:db8::1\" } ] } } } } RegionID 可以在 900-999 任选；OmitDefaultRegions 为 true 时，只会使用自建的，不会再使用官方的 derp 服务器。 最后使用 tailscale netcheck 验证即可。 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:4:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#自建-derp"},{"categories":["网络"],"content":" 进一步优化可以创建一个启动、停止脚本，方便进行操作，下面两个版本各取所需。 sh # create /opt/derper/runderper # open SSL ver #!/bin/sh cd /usr/local/gopath/bin nohup ./derper -hostname \u003cDOMAIN\u003e -c=derper.conf -a :\u003cPORT\u003e -http-port -1 -certdir /usr/local/cert -certmode manual -verify-clients -stun \u003e console.log 2\u003e\u00261 \u0026 echo $! \u003e app.pid # disabled SSL ver #!/bin/sh cd /usr/local/gopath/bin nohup ./derper -hostname \u003cDOMAIN\u003e -c=derper.conf -a :\u003cPORT\u003e manual -verify-clients -stun \u003e console.log 2\u003e\u00261 \u0026 echo $! \u003e app.pid # 停止脚本 /opt/derper/stopderper #!/bin/sh kill `cat app.pid` rm -rf app.pid 如果你需要 SSL，把 SSL 证书上传到 /usr/local/cert 文件夹，证书命名格式为 \u003cDOMAIN\u003e.\u003cSUFFIX\u003e，将证书文件后缀改为 crt ，密钥文件后缀改为 key。 创建服务（开机自启 systemctl enable --now derper.service） ini # /etc/systemd/system/derper.service [Unit] Description=Derper服务 After=network.target [Service] Type=forking ExecStart=/opt/derper/runderper ExecStop=/opt/derper/stopderper [Install] WantedBy=multi-user.target 参考：自建 Tailscale DERP 服务教程 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:4:1","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#进一步优化"},{"categories":["网络"],"content":" 自建 HeadscaleHeadscale 可以理解为是开源的 Tailscale，因为官方的 Tailscale 控制端并不是开源的。 headscale 是用 Go 写的，通过源码编译的话需要准备 Go 环境，也可以通过 docker 来部署。 按照官方文档的方式部署非常简单，一路执行即可，我也收集了一下网友的最佳实践，博主自己目前还没有部署，使用的官方的控制端。 sh # 下载二进制版本 VER=0.24.1 wget https://github.com/juanfont/headscale/releases/download/v${VER}/headscale_${VER}_linux_amd64 # 下载同版本的示例配置文件 mkdir /etc/headscale/ wget -O /etc/headscale/config.yaml https://raw.githubusercontent.com/juanfont/headscale/v${VER}/config-example.yaml chmod a+x /usr/local/bin/headscale # 创建配置目录 mkdir -p /etc/headscale # 创建证书和数据目录 mkdir -p /var/lib/headscale # 创建空数据库 touch /var/lib/headscale/db.sqlite # 创建 sock，创建文件夹 mkdir /var/run/headscale # 创建文件 touch /var/run/headscale/headscale.sock # adduser --no-create-home --disabled-login --shell /sbin/nologin --disabled-password headscale # 修改 Owner # chown -R headscale:headscale /var/lib/headscale # 测试运行 headscale serve # 启动服务 systemctl start headscale # 关闭服务 systemctl stop headscale # 开机自启 systemctl enable headscale # 查看状态 systemctl status headscale Docker 部署参考： yaml services: headscale: image: headscale/headscale:0.23.0-alpha8 container_name: headscale restart: always command: serve volumes: - ./config:/etc/headscale ports: - 8080:8080 - 9090:9090 配置文件是通用的，之后就可以使用 headscale 命令来创建用户之类的操作了。 需要注意的是 headscale 默认是没有 UI 的，不过有一些第三方 UI 可供选择，例如 headscale-ui、headscale-admin 客户端使用： sh # 浏览器打开 apple/windows http://你的域名或ip:8080/apple # 执行页面中的命令行 tailscale login --login-server http://你的域名或ip:8080 # 获取返回的命令 headscale -n 命名空间 nodes register --key nodekey:上面这行命令返回结果的key # 到Headscale服务器上执行返回的命令 ### linux tailscale up --login-server=http://你的域名或ip:8080 --accept-routes=true --accept-dns=false # 获取返回的命令 headscale -n 命名空间 nodes register --key nodekey:上面这行命令返回结果的key # 到Headscale服务器上执行返回的命令 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:5:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#自建-headscale"},{"categories":["网络"],"content":" 配置文件headscale 的主要配置文件： yml # /etc/headscale/config.yaml # 这里填写你的实际外网地址,域名或ip都可以 server_url: http://XXX.XXX.XXX.XXX:8080 # Headscale 要绑定/监听的 Port listen_addr: 0.0.0.0:8080 metrics_listen_addr: 0.0.0.0:9090 # 为客户端分配的 IP 段 ip_prefixes: - fd7a:115c:a1e0::/48 - 10.1.0.0/16 randomize_client_port: true # 修改对自己来说方便的DNS，可以保持默认 dns_config: # 使用本地 DNS override_local_dns: true nameservers: - 223.5.5.5 # 如果启用，必须配置其他部分，如 https、TLS derp: server: enabled: false # 建议关闭Magic DNS，否则有可能造成客户端无法正常上网 magic_dns: false # 修改Socket存储位置 unix_socket: /var/run/headscale/headscale.sock 要使用 DERP 参考文档，注册服务实现自启动： properties # /etc/systemd/system/headscale.service [Unit] Description=headscale controller After=syslog.target After=network.target [Service] Type=simple User=headscale Group=headscale ExecStart=/usr/local/bin/headscale serve Restart=always RestartSec=5 # 可选的权限和安全配置 NoNewPrivileges=yes PrivateTmp=yes ProtectSystem=strict ProtectHome=yes ReadWritePaths=/var/lib/headscale /var/run/headscale AmbientCapabilities=CAP_NET_BIND_SERVICE RuntimeDirectory=headscale [Install] WantedBy=multi-user.target 常用命令： sh # 启动服务 systemctl start headscale # 关闭服务 systemctl stop headscale # 开机自启 systemctl enable headscale # 查看状态 systemctl status headscale # 显示节点列表 headscale nodes ls # 删除节点 headscale nodes delete -i \u003cid\u003e # 启动服务 systemctl start headscale # 开机自启 systemctl enable headscale # 查看状态 systemctl status headscle # 创建命名空间 headscale namespaces create \u003cnamespace\u003e # 查看命名空间列表 headscale namespaces list # mac ping /Applications/Tailscale.app/Contents/MacOS/Tailscale ping 100.64.0.2 参考：Tailscale 自建 (Headscale 及 Derp) ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:5:1","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#配置文件"},{"categories":["网络"],"content":" 与魔法软件共存虽然可以使用 exit node 节点代理所有流量，但是家用带宽的上行一般是不够用的，而 Tailscaled 默认也会创建一个 Tun 和魔法工具一样的套路（但是正常的 OpenVPN 之类的是可以共存的），同时运行他们一般是冲突的。 有一种解决方案是将 Tailscaled 作为一个 socks5 代理的方式运行，但是我感觉不妥。感兴趣可以搜索一下。 移动端就直接建议魔法软件使用系统代理模式，不要用 Tun 了，把 VPNService 留给 Tailscaled。 PC 端可以在魔法软件尝试配置排除 Tailscaled 的 100.x 网段（tun 下的 exclude-interface 和 route-exclude-address 配置），然后关闭本地 MagicDNS（取消勾选 Use Tailscale DNS settings），但是一般情况应该也没啥影响。 yaml # 参考配置 tun: enable: true exclude-interface: - Tailscale # macOS 名字可能是 utun 固定前缀的 auto-route: true auto-redirect: true route-exclude-address: - 100.64.0.0/10 或者考虑曲线救国，搭建一个 OpenVPN 连过去。 ","date":"2025-08-24","objectID":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/:6:0","series":null,"tags":["Tailscale"],"title":"PVE中使用Tailscale","uri":"/pve%E4%B8%AD%E4%BD%BF%E7%94%A8tailscale/#与魔法软件共存"},{"categories":["运行日志"],"content":"关于密码管理工具也用过一些，从最基本的 Chrome 自带（警告，有丢失风险，包括存储的通行密钥），到 LastPass，再到 Keepass，最后选择使用 Bitwarden。 也许 1Password 体验会更好，但是我作为穷鬼，就不去打扰了。 Bitwarden 是一款免费且开源的密码管理工具，它可以帮助用户安全地存储和管理他们的密码，并在不同设备之间同步。它通过加密的密码库来保护用户的敏感信息，即使是 Bitwarden 团队也无法访问用户的密码。 Bitwarden 官方的服务器我也用了很长时间，但是有个问题，现在大多数网站都支持 2FA 也就是两步验证，虽然免费的 Bitwarden 可以存储 2FA 密钥，但是填充要高级用户。 最后我选择使用它的自托管，也就是自己搭建一个 Bitwarden 服务端，这样数据不光可以完全由我们自己掌握，还可以使用 2FA 填充这样的高级功能。 ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#"},{"categories":["运行日志"],"content":" 准备工作看了下官方的配置要求 ，2G RAM 起步，好家伙，这有点离谱；不过我又发现了 Vaultwarden 这个项目： Vaultwarden 是一个用于本地搭建 Bitwarden 服务器的第三方 Docker 项目。仅在部署的时候使用 Vaultwarden 镜像，桌面端、移动端、浏览器扩展等客户端均使用官方 Bitwarden 客户端。 Vaultwarden 很轻量，对于不希望使用官方的占用大量资源的自托管部署而言，它是理想的选择。 除不支持 Bitwarden 官方企业版的部分功能外，其他大部分功能均免费支持。并跟随官方版本保持及时更新。 官方版使用 .Net 开发，使用 MSSQL 数据库，要求至少 2GB 内存；Vaultwarden 使用 Rust 编写，改用 SQLite 数据库（现在也支持 MySQL 和 PostgreSQL），运行时只需要 10M 内存，可以说对硬件基本没有要求。 本来是想放到我的服务器上，但是想了想我那服务器半年都可能不会关注一次，就是出问题也大概率发现不了；还是放家里的服务器安全些，虽然持久化都是加密存储，就算被攻破也不会出现明文泄露的情况。 反正部署完直接端口映射出去公网也能用。 ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:1:0","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#准备工作"},{"categories":["运行日志"],"content":" 部署Vaultwarden 的部署非常简单，如果是和我一样简单使用的话，按照官方的文档几条命令就完事，毕竟是 Docker 部署。 sh docker run -d --name vaultwarden -v /vw-data/:/data/ -p 80:80 vaultwarden/server:latest 环境变量： 名称 含义 ADMIN_TOKEN 管理员后台使用，相当于密码 SIGNUPS_ALLOWED false 其他的环境变量参考文档吧，我目前就用到这几个。 ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:2:0","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#部署"},{"categories":["运行日志"],"content":" 启用 SSL这时候如果尝试访问 Web 服务，大概率进不去，因为要正常运行 Vaultwarden，几乎必须启用 HTTPS，这是因为 Bitwarden 网络密码库使用的 Web Crypto API，大多数浏览器只有在 HTTPS 环境下才能使用。 官方推荐是使用一个 Nginx 代理，HTTPS 由反代负责，还需要申请一个证书，可以使用 ACME 自动申请续订，或者自签一个倒是也能用。 但是我有个黑群晖，并且已经搞了 HTTPS，直接使用它内置的反代就可以了，如果你也有群晖或者其他 NAS 可以在 NAS 里找找，一般都有。 群晖是在：控制面板 - 登录门户 - 高级 - 反向代理服务器，来源一定要选 HTTPS，并且启用 HSTS；自定义标题中点新增选择 WebSocket 启用 WebSocket 支持。 ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:3:0","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#启用-ssl"},{"categories":["运行日志"],"content":" 群晖自动申请 Let’s Encrypt 证书我这里使用 Cloudflare 来做验证，需要去 Cloudflare 申请好 Token，有修改 DNS 的权限（域名页面的右下角可以看到 API 相关的信息）；然后进入 ssh 执行下面的命令： sh # 切换到root账户 sudo su # 进入root home目录 cd ~ # 安装 ACME curl https://get.acme.sh | sh -s email=xxxx@gmail.com --force ## 设置CF Account信息 export CF_Account_ID=\"\" ## 设置CF Token信息 export CF_Token=\"\" # 进入/root/.acem.sh目录 cd /root/.acme.sh # 申请证书，--server letsencrypt 指定申请 letsencrypt 证书 # -d example.com 指定要申请证书的域名是 example.com # -d *.example.com 说明申请的证书是泛域名证书 ./acme.sh --issue --server letsencrypt --dns dns_cf -d example.com -d *.example.com # 若无意外，证书将会申请成功，并存放在.acme 目录下 # 安装证书 # acme 可以直接调用群晖本地的工具生成临时用户进行证书安装。 # 设置使用临时管理员账户 export SYNO_USE_TEMP_ADMIN=1 # 在/root/.acme.sh目录下执行命令部署证书 # example.com是前面申请证书的域名 ./acme.sh --deploy --deploy-hook synology_dsm -d example.com 之后进入群晖的任务计划，新建一个任务，使用 root 执行，因为 Let’s Encrypt 的证书只有 90 天有效期，需要选择合适的日期进行重复执行，例如每周一次检查。 输入执行命令：/root/.acme.sh/acme.sh --cron --home /root/.acme.sh 详细内容参考这位大佬的文章 ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:3:1","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#群晖自动申请-lets-encrypt-证书"},{"categories":["运行日志"],"content":" 开始使用搭建完毕后，首先打开映射的 Web 服务，界面和 Bitwarden 官方基本是一样的，URL 后面加 /admin 进入管理页面，输入配置的 ADMIN_TOKEN 就进去了。 进去需要做两个事，因为关闭了自由注册，所以必须管理员邀请注册，但是邀请注册是通过邮件发送的，所以需要先配置一个邮件 SMTP 服务。 这里我因为有个阿里企业邮箱，就填了我自己的邮件服务，但是发现免费版本有概率会被 Spam，不是被放垃圾邮件就是发不出去； 后面找了下免费的类似服务，发现一个 AhaSend，已经搭建好了，后续可能会测试一下，免费的真是且用且珍惜，最终不会还是要自己搭吧，到时候再说。 AhaSend 的免费套餐也够用了，在 Credentials 新建一个 SMTP 凭证就可以使用了。 不确定使用国内邮箱或者 Outlook 会不会有问题。 邮件服务配完直接填邮箱邀请用户就可以了，按照邮件链接注册，完成。 之后就可以从官方的 Bitwarden 导出密码库，导入我们自己的服务。 之后随便找个客户端或者浏览器扩展，添加新用户，选择自托管，输入我们的域名，登录完成。 强烈建议保存密码的时候手动编辑下名称和分组，一时默认爽，整理的时候头都大了。 Tip 如果感觉官方的 App 不好用，可以试试 Keyguard ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:4:0","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#开始使用"},{"categories":["运行日志"],"content":" 导入 2FA因为我平常使用的是 Google Authenticator，现在想转移到 Bitwarden 中一份，当初并没有保存密钥，而 Google Authenticator 中也不支持查看原始密钥； 后来发现了 decodeGoogleOTP 这个项目，可以从 Google Authenticator 的转移二维码中解析原始数据； 将 Google Authenticator 导出的二维码图片保存，执行 sh decodeGoogleOTP -i \u003cinput file\u003e -j \u003coutput file\u003e 执行完毕，得到解密后的 json，把密钥输入到 Bitwarden 就可以了。 记得清理或者保护好自己的 2FA。 ","date":"2025-08-19","objectID":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/:5:0","series":null,"tags":["Bitwarden","Vaultwarden"],"title":"Bitwarden自托管搭建","uri":"/bitwarden%E8%87%AA%E6%89%98%E7%AE%A1%E6%90%AD%E5%BB%BA/#导入-2fa"},{"categories":["计算机驯服计划"],"content":"起因是最近重装了系统，虽然有备份还原可用，但是垃圾也会一起还原，所以直接从头开始，比较之前也装了很多乱七八糟的东西，但是基本就没用过。。。。 但是现在都已经全部弄完了，现在才想起来记录一下，emmmm，之后想到了就会更新的。 目前我使用的设备有 Windows11 台式机、一台 MBP、一台 MacMini，所以软件生态会分 Win 和 macOS，开发使用 macOS 居多，其他都是 Win。 当然有些云服务类就不限于平台了，内容比较杂，因为现在都是使用中状态，大多数也只能想起来再记录或者下次重装系统的时候再整理了。 一样是不在多而在于精，在可用的情况下，最多保留个备用的完事，再多同类的也大概率不会用。 缓慢整理中 也许会忘记也说不定呢. ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:0:0","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#"},{"categories":["计算机驯服计划"],"content":" Windows","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:1:0","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#windows"},{"categories":["计算机驯服计划"],"content":" 终端工具还是因为习惯了 Xshell 了，但是貌似 WindTerm 用的人很多 Xshell putty WindTerm Termius 如果用，推荐这个补丁 Termius 之前在 macOS 上应该用过，怎么说呢，感觉卡卡的（Electron 你不要过来啊），外加没中文劝退了。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:1:1","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#终端工具"},{"categories":["计算机驯服计划"],"content":" 效率工具装机必备，提升操作效率！ PixPin - 截图贴图 Snipaste 也很好用，可惜不支持 OCR Ditto - 剪切板管理 作者貌似删库了，替代选择：CopyQ FastKeys 强大的自动化工具，最常用的是 Mac 上类似的\"自定义短语\"功能。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:1:2","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#效率工具"},{"categories":["计算机驯服计划"],"content":" 补丁增强可能有风险，谨慎使用（指被封号）。 BetterWX WX防撤回、多开等 WO Mic 还没舍得买麦克风，用手机当作电脑麦克风 Windows Update Disabler 最近的 Windows11 更新补丁导致 SSD 掉盘的风波，真的不太信任微软的这帮啊三了。 主题美化 niivu DevManView 驱动管理，IOBit 的 Driver Booster PRO 也很不错。 WizTree 磁盘空间分析，另一个古老软件是 SpaceSniffer ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:1:3","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#补丁增强"},{"categories":["计算机驯服计划"],"content":" 快速启动基本再用 uTools，最近看官方好像限制插件数量，引起不小的风波，如果没影响继续使用，有影响就换，我插件用的很少，基本就用个 截图 OCR + 翻译 uTools Flow Launcher Listary Quicker ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:1:4","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#快速启动"},{"categories":["计算机驯服计划"],"content":" 远程控制Rustdesk 能自建最好，我最近也打算自建一个试一下； Rustdesk 网易 UU 远程 TeamViewer 除非必要，目前已不再推荐向日葵、ToDesk 之类，体验并不好。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:1:5","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#远程控制"},{"categories":["计算机驯服计划"],"content":" macOS配置文件同步推荐使用 Dotbot 初始化新系统，直接 git pull 下来 install 全部配置完毕的感觉太爽了。 brew 的备份使用 homebrew-bundle，例如： sh # 备份 brew bundle dump --describe --force --file=\"~/Desktop/Brewfile\" # 如果你使用 brew 安装了 MAS 的 App 需要提前安装 brew install mas # 恢复 brew bundle --file=\"~/Desktop/Brewfile\" ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:2:0","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#macos"},{"categories":["计算机驯服计划"],"content":" 终端工具参考 Windows 中的介绍，Xshell 没有 Mac 版，现在使用默认终端 + 食用； Ghostty FinalShell Termius kitty WindTerm Termius 感觉卡顿严重，也许我机器太老了。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:2:1","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#终端工具-1"},{"categories":["计算机驯服计划"],"content":" 通用\u0026服务类","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:0","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#通用服务类"},{"categories":["计算机驯服计划"],"content":" 插件沉浸式翻译删掉了，不光是因为最近的隐私事件，VIP 功能太杂了，我其实都用不上，换成简约翻译。 Kiss Translator 配合 L 站的 DeepLX 效果更好 Auto-Group Tabs uBlock Origin uBlacklist tampermonkey Bitwarden Checker Plus for Gmail Elmo Chat Hover Zoom+ JSON-handle Octotree SteamDB SuperCopy Wikiwand - Elevate Wikipedia with AI Wikipedia Search 划词翻译 几枝 為什麼你們就是不能加個空格呢 扩展管理器（Extension Manager） 终结内容农场 不太常用的一些： Talend API Tester WebRTC Control Elmo Chat Obsidian Web Obsidian Web Clipper Screenity SmartProxy ScriptSafe Awesome Screenshot 截图录屏 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:1","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#插件"},{"categories":["计算机驯服计划"],"content":" 脚本 LinkSwift MiniblogImgPop - 微博浮图 与 Hover Zoom+ 插件可以二选一 CSDNGreener 中文维基百科优先简体中文 自动无缝翻页 网盘自动填写访问码 HTML5视频播放器增强脚本 备用 TimerHooker 去除博客导流公众号 AI 验证码自动识别填充 万能验证码自动输入 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:2","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#脚本"},{"categories":["计算机驯服计划"],"content":" API 调试Postman 用惯了，但是有点越来越恶心了，替代的也用了不少，还是找不到满意的。 Reqable Apifox Apifox 很多人推荐，但是个人还是不太喜欢，功能太多也有点烦，比较喜欢极简主义的；并且也是强制登录，强制云同步。 并且大概率也是（Electron 你不要过来啊） ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:3","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#api-调试"},{"categories":["计算机驯服计划"],"content":" AI 开发辅助目前用的还是较少，但是很多人在吹，老了折腾不动了，思想也落后了还是觉得 AI 的代码不如自己写的好，速度确实快，适合一些简单、要快速开发的项目吧。 Roo Code 具有智能代码生成和重构功能的高级 AI 驱动编码助手。 应该就是 CC 这种的替代版，可以选择多种模型，比如本地部署的，以达到完全免费使用。 VSC Only RunVSAgent 使开发者能够在 JetBrains IDEs 或其他 IDE 平台中运行基于 VSCode 的编码代理和扩展。 应该是基于 Roo Code 的。 Claude Code Router 将 Claude Code 请求路由到不同的模型，并自定义任何请求。 看到有人发某 V 站的秀优越的帖子，以防有人不知道，像我这种穷鬼，Claude Code 是用不起的，别再说什么程序员一天的收入来买 $200 的 AI 也是物超所值的。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:4","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#ai-开发辅助"},{"categories":["计算机驯服计划"],"content":" 魔法相关Win 优先 Spark，Mac 优先 Surrge 学习版（可惜新版本的 TUN 需要关 SIP）。 sing-box 还是有点望而却步。 裸内核运行也不是不可能，搭配 zashboard 面板，也未必会差。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:5","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#魔法相关"},{"categories":["计算机驯服计划"],"content":" 影音聚合除必要情况，使用 Emby 公费服，一个月几块钱换来的质量比 CMS 的那些资源要高的多。 主要是亲戚朋友让你给找资源，总不能给个网盘分享吧，不是 VIP 的体验也没多好，还是在线看的体验好一些，可以直接从这些资源站找，比一般的满屏广告的野站要好的多。 MoonTV Web 服务聚合，对应的独立客户端选择 LibreTV-App 更新：存活了不到一个月，被人举报 DMCA 了，转生版本 LunaTV，不过作者不打算开源了，具体资源关注作者吧。 爱看机器人 TV 直播源 关注肥羊的 ALLINONE，可惜被人给恶心的退坑了，备用关注 Mursor 大佬 其他的还真没发现有好用的。 音乐聚合 HE-Music 需要 L 站 lv2+，且用且珍惜 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:3:6","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#影音聚合"},{"categories":["计算机驯服计划"],"content":" 其他 MiscLinux 发行版选择？ 开发 GUI 的 Ubuntu，服务器 Debian，折腾 Arch； 像折腾又不想太折腾，基于 Arch Linux 的 CachyOS ？ ONLYOFFICE 好用的 Office 替代，其他还有知名的 LibreOffice。 CloudDrive2 网盘聚合和本地挂载，其他的还有 AList 的分叉版本 OpenList。 ","date":"2025-08-12","objectID":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/:4:0","series":null,"tags":["软件"],"title":"我的软件清单\u0026军火库","uri":"/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%E5%86%9B%E7%81%AB%E5%BA%93/#其他-misc"},{"categories":["网络"],"content":"不少小伙伴有公网访问局域网的需求，也许是在外面需要访问家里的网络，也可能是公网服务需要回调你在开发的程序，大部分情况下实现内网穿透并没有那么难；我主要是记录下对 NAT 技术的理解，以及它对内网穿透的影响。 看你下大约在 7 年前我就做过一篇关于内网穿透的笔记，现在我觉得有必要进行整理下给正式的发出来，当年还没有 AI 很多解释还需要自己去找，现在问 AI 方便的多，我也是精简一下做个记录。 Tip 由于整个 HTTP 请求到回复过程牵扯到的技术太多，这里默认当作各位有一定的了解，如果不理解可以问下 AI，这对理解和解决一些网络问题，或者配置\"魔法\"软件的时候很有用。 这里主要关注这个链路中 NAT 和 IP 的部分。 由于联网设备众多和国际上我们分得的 IPv4 数量无法保证为每一个宽带用户提供全球唯一的公网 IPv4 地址。因此很多用户会发现通过路由器端查看到的 WAN 端 IP 与百度 “IP” 关键词所得到的 IP 不一致，并且前者的 IP 为一个私有 IP。 而还有一些情况下，公网IP比较昂贵，企业虽然本身也持有少量的独立的公网IP，但是由于成本限制无法为企业内每一台主机都提供一个公网IP，或者内网并不是所有服务都需要暴露到公网中进行访问，那么企业有可能就会使用 NAT 技术将大量的内网 IP 通过一定规则映射到公网 IP 上。 而最常见的其中一种技术就是 NAPT，也叫“网络端口地址转换”。因为一般一个服务都是通过一个端口来提供，因此通过这种方式可以将特定的服务通过特定的规则开放到少量的公网 IP 上。 国内家庭宽带（移动尤其严重）常见的就是 100 开头的地址，公司学校的网络也可能如此，这种情况无法通过**端口映射 ** 等方法让内网设备暴露给外网，只能通过内网穿透方式。 我当前使用的联通改桥接后获取到的是公网 IP，我目前虽说不需要内网穿透了，但是大部分人并没有我这么好运气。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:0:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#"},{"categories":["网络"],"content":" 什么是NAT在计算机网络中，网络地址转换（Network Address Translation，缩写为 NAT），是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。 假设我的 PC 机是 192.168.1.100，我的手机是 192.168.1.101，宽带拨号获取到的公网 IP 是 203.0.11.12，这个 IP 地址就代表着我家网络总出口； 现在如果我访问淘宝，淘宝服务器只能看到 203.0.11.12 这个 IP 的某个端口（某个设备）访问了它，不能确定具体是那个设备，这就导致了即使知道我家 IP 是 203.0.11.12，也不能直接地对网络下具体的设备发起通信。 我们作为客户端请求公网服务使用的是系统分配的临时的随机端口，而淘宝网作为服务是使用的固定端口，也是为了让别人都能找到它，具体就是访问时可能就是 203.0.11.12 的 10101 端口与淘宝服务器的 443 端口建立连接。 但是在路由器大多数也是网关（理解为大门，所有的数据进出都需要经过它）这个关键角色下，它知道并且会记录家里的那个设备访问你外面的那个服务，当别人给你回复数据的时候先经过网关，再按照对应表转换成给具体某个设备的数据包。 大体先有个概念，下面会继续解释。 这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问因特网的私有网络中。根据规范，路由器是不能这样工作的，但它的确是一个方便且得到了广泛应用的技术。当然，NAT 也让主机之间的通信变得复杂，导致了通信效率的降低。 NAT 最初发明的一大目的就是解决公网 IP 的 IPv4 地址资源枯竭的问题，所以国内大城市的主流运营商经常会使用这种方法来规避资源枯竭的问题（我国普及 IPV6 可能还需要一定时间），端口 NAT 转换让 IP 地址得到了极大的利用，NAT 的一个特点就是：对外隐藏了真实地址，有的甚至还不止一层 NAT。 在一定程度上，NAT 依赖于本地网络上的一台机器来初始化（这个活一般是路由器负责）和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。 运营商会贴心的禁用高危端口，所以即使有公网 IP，80、443、22 这些端口也是没法用的。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#什么是nat"},{"categories":["网络"],"content":" 基本网络地址转换(Basic NAT)这一种也可称作 NAT 或“静态 NAT”，在 RFC 2663 中提供了信息。它在技术上比较简单，仅支持地址转换，不支持端口映射，这种情况应该是很少见的吧。 但是由于改变了 IP 源地址，在重新封装数据包时候必须重新计算校验和，网络层以上的只要涉及到IP地址的头部校验和都要重新计算。 Basic NAT 要维护一个无端口号 NAT 表，结构如下: 内网IP 外网IP 192.168.1.55 219.152.168.222 192.168.1.59 219.152.168.223 192.168.1.155 219.152.168.224 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:1","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#基本网络地址转换basic-nat"},{"categories":["网络"],"content":" 网络地址端口转换(NAPT)这种方式支持端口的映射，并允许多台主机共享一个公网 IP 地址。 支持端口转换的 NAT 又可以分为两类：源地址转换和目的地址转换。 前一种情形下发起连接的计算机的 IP 地址将会被重写，使得内网主机发出的数据包能够到达外网主机。 后一种情况下被连接计算机的 IP 地址将被重写，使得外网主机发出的数据包能够到达内网主机。 实际上，以上两种方式通常会一起被使用以支持双向通信 。 NAPT 维护一个带有 IP 以及端口号的 NAT 表，结构如下: 内网IP 外网IP 192.168.1.55:5566 219.152.168.222:9200 192.168.1.59:80 219.152.168.222:9201 192.168.1.59:4465 219.152.168.222:9202 在 NAT 网关上会有一张映射表，表上记录了内网向公网哪个 IP 和端口发起了请求，然后如果内网有主机向公网设备发起了请求，内网主机的请求数据包传输到了 NAT 网关上，那么 NAT 网关会修改该数据包的源 IP 地址和源端口为 NAT 网关自身的 IP 地址和任意一个不冲突的自身未使用的端口，并且把这个修改记录到那张映射表上。 最后把修改之后的数据包发送到请求的目标主机，等目标主机发回了响应包之后，再根据响应包里面的目的 IP 地址和目的端口去映射表里面找到该转发给哪个内网主机。 这样就实现了内网主机在没有公网 IP 的情况下，通过 NAPT 技术借助路由器唯一的一个公网 IP 来访问公网设备。 说一下它的特点吧，也可以说是 NAT 的特点： 网络被分为私网和公网两部分，NAT 网关设置私网到公网的路由出口. 网络只能由私网侧发起，公网无法主动访问私网主机 (是这样设计的,但是可以通过打洞的方式，就是内网穿透) NAT 网关在两个访问方向上完成两次地址的转换，出口替换源地址，入口替换目的地址 NAT 网关的存在对通信双方保持透明 NAT 网关为了实现双向翻译，需要维持一张关联表，将会话信息保存 从这里我们可以看到，NAPT 只解决了内网主机在没有公网 IP 的情况下如何访问公网主机的问题，但是并不能解决公网主机如何主动向内网主机发起请求的问题。 Tip NAT 还可以用作负载均衡、失效终结、透明代理等。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:2","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#网络地址端口转换napt"},{"categories":["网络"],"content":" NAT的类型在确定内外穿透方案之前，需要先了解一下自己网络的 NAT 类型，不同的类型穿透的难度是有区别的，根据映射关系中对外部主机发送的数据的限制可以分为以下几种类型： NAT 类型 映射行为 外部主机发送到内部（谁能发回） 穿透难度 Full Cone 全锥形 固定映射：内IP:内端口 -\u003e 外IP:外端口，对所有外部连接生效。 任何外部主机只要知道这个公网IP和端口，就能向内网主机发送数据。 最易 Restricted Cone 受限锥形 固定映射：内IP:内端口 -\u003e 外IP:外端口 内网主机需先向外部主机发送数据，该外部主机才能向内网主机发送数据。 容易 Port Restricted Cone 端口受限锥形 固定映射：内IP:内端口 -\u003e 外IP:外端口 内网主机需先向外部主机发送数据，然后被内网主机访问过的这个外部IP和端口可以回复数据 中等 Symmetric 对称形 动态映射：内IP:内端口 -\u003e 随机外IP:不同的外端口。每次与新目的通信都可能分配新端口。 内网主机与每个外部主机通信时创建的 IP 和端口可以回传数据 最难 Port Restricted Cone NAT 和 Restricted Cone NAT 的主要区别点: 特性 Restricted Cone NAT (限制锥形 NAT) Port Restricted Cone NAT (端口限制锥形 NAT) 映射端口 对于同一个内部 IP:端口，外部映射端口始终不变，无论目标是谁。 对于同一个内部 IP:端口，外部映射端口始终不变，无论目标是谁。 入站过滤 更宽松 更严格 入站条件 必须是内部主机主动发送过包的目标 IP 的入站包才允许通过。 必须是内部主机主动发送过包的目标 IP 和目标端口 的入站包才允许通过。 源端口限制 不限制外部入站包的源端口。只要源 IP 匹配即可。 严格限制外部入站包的源端口。源 IP 和源端口都必须匹配。 UDP 打洞 更容易。只要双方都向对方的公共 IP 发送过包，就能打通。 可以打洞。双方必须同时向对方的公共 IP:Port 发送包，才能打通。因为入站包的源 IP 和源端口都必须匹配。 有些人（大部分游戏玩家）也会将 NAT 分为以下类别： NAT Type 1 (Open / 开放) 对应的技术 NAT 类型： 无 NAT 或者 Full Cone NAT (如果确实有NAT但非常宽松，行为上等同于没有限制)。 NAT Type 2 (Moderate / 中等) 对应的技术 NAT 类型： Restricted Cone NAT 或 Port Restricted Cone NAT。 NAT Type 3 (Strict / 严格) 对应的技术 NAT 类型： Symmetric NAT。 或者简单粗暴按照上面表格的四种类型 NAT 1、2、3、4，测试自己是那种 NAT 类型可以使用一些公共 STUN，小米也提供了一个1。我也找了一些开源工具2，但是整体来说 Surfboard 自带的 NAT 检测更好用，这类魔法软件大多也自带测试工具。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:2:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#nat的类型"},{"categories":["网络"],"content":" STUNSTUN (Session Traversal Utilities for NAT) 协议的主要作用是帮助内部客户端发现它自己被 NAT 映射后的公共 IP 地址和端口，以及识别其所处的 NAT 类型。 工作原理是客户端向一个已知的 STUN 服务器发送请求。STUN 服务器会回复客户端它看到的客户端的公共 IP 和端口。 仅仅通过一个简单的绑定请求是无法识别 NAT 类型的。STUN 协议定义了更复杂的测试机制来区分不同的 NAT 类型。这通常涉及客户端向 STUN 服务器的不同端口或不同的服务器 IP 地址发送额外的请求，并分析服务器的响应行为。 客户端首先向 STUN 服务器的 IP1:Port1 发送一个请求。服务器在响应中返回客户端的公共 IP:PortA。 然后，客户端要求 STUN 服务器由另一个 IP2:Port2 发送一个响应包（或者 STUN 服务器本身就用不同的 IP/Port 回复）。 如果客户端能成功收到来自 IP2:Port2 的响应，说明 NAT 是 Full Cone NAT。因为 Full Cone NAT 对所有外部流量都是开放的，只要内部有出站连接，外部任何源地址和端口都可以发送数据回来。 如果客户端收不到响应，说明 NAT 可能不是 Full Cone，需要进一步测试。 客户端向 STUN 服务器的 IP1:Port1 发送一个请求，得到映射后的公共 IP:PortA。 然后，STUN 服务器从一个不同的 IP 地址 (例如，IP2:Port2) 向客户端的公共 IP:PortA 发送一个请求（注意，这个请求的源 IP 改变了，但端口可能相同或不同）。 如果客户端能收到来自 IP2:Port1 (相同端口，不同 IP) 的响应，但收不到来自 IP2:Port2 (不同 IP，不同端口) 的响应，则可能是 Port Restricted Cone NAT。 因为 Port Restricted Cone NAT 允许来自原始目标 IP 相同端口的响应，但会过滤掉来自不同端口的连接。 如果客户端能够收到来自 IP2:Port1 和 IP2:Port2 的响应，则可能是 Restricted Cone NAT。 因为 Restricted Cone NAT 允许来自不同 IP 但相同端口的响应，并且可能也允许来自不同端口的响应。 这部分测试通常比较复杂，STUN 客户端会通过多次请求和比较响应来确定 NAT 的过滤规则。 客户端从同一个内部 IP:Port，向 STUN 服务器的不同 IP 地址或不同端口发送绑定请求。 如果每次请求得到的外部映射端口都不同，那么几乎可以确定是 Symmetric NAT。 UDP 打洞对于 Full Cone NAT 和 Restricted Cone NAT 还是很简单的，对于 Port Restricted Cone NAT 的关键在于外网IP_目标是受限制的，必须是内部主机主动发送过包的目标 IP。即使外部包的源端口不同，只要源 IP 匹配，它就能进来。 STUN 主要用于识别 NAT 类型和获取映射信息。它不能直接穿透 Symmetric NAT，因为它无法预测 Symmetric NAT 每次都会改变的端口映射。 对于 Cone NATs（Full, Restricted, Port Restricted），STUN 可以协助进行 UDP 打洞。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:2:1","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#stun"},{"categories":["网络"],"content":" 关于私有地址复习下网络方面的知识，这个肯定都学过，至于还记不记得….. 因特网域名分配组织 IANA 组织（Internet Assigned Numbers Authority）保留了以下三个 IP 地址块用于私有网络。 10.0.0.0 - 10.255.255.255 (10/8比特前缀) 172.16.0.0 - 172.31.255.255 (172.16/12比特前缀) 192.168.0.0 - 192.168.255.255 (192.168/16比特前缀) 主流的家用路由器使用 C 类私有地址作为路由器 LAN 端的 IP 地址较多，所以我们可以看到路由器设置页面的 IP 一般都为 192.168 开头。 一些大型企业就需要使用B类甚至A类地址段作为内部网络的地址段。A类地址的容量最大，可以容纳16777214个主机，B类地址可以容纳65534个主机，C类地址可以容纳254个主机。 还有就是 100 开头的这种 IP，大多也不是公网，一般用作运营商级 NAT。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:3:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#关于私有地址"},{"categories":["网络"],"content":" 为什么要内网穿透先说说家庭宽带的情况吧。家庭宽带如果没有公网 IP，那么意味着你在本机上监听的任何端口，都只能在本机网卡所在的网络中访问（LAN），也就是常说的内网/局域网。 如果这种情况下想要让 WAN 端（如果运营商为你分配了公网 IP，那么 WAN 端所连接到的网络通常就是公网），那么需要在路由器上做端口映射。比如说路由器的 LAN IP 为 192.168.1.1，WAN IP 为 23.23.23.23； 我想让内网 192.168.1.2 主机的 80 端口提供的 HTTP 服务器直接能够在公网中通过 http://23.23.23.23 访问，那么就要将 192.168.1.2:80 映射到 23.23.23.23:80 上（当然，家庭宽带是不会给你开放 80 端口的）。 但是通常情况下，运营商是不会给普通用户公网 IP 的。那么用这种方法映射，在公网仍然是无法访问的，因为你的路由器 WAN 端连接的又是运营商更上一级的路由器 LAN 端，严重一点，甚至是层层连接最后才到公网，这种行为称作流量穿透。 国内某电，某动的宽带就有大量这种行为。通过流量穿透的方式来提供的宽带服务，看似便宜，实则影响很大，由于大家公用一个 IP，可能会导致很多网站的反 SPAM 策略伤及无辜，或者内部为了节省带宽，使用缓存，导致一些不该缓存的敏感安全页面被缓存起来，甚至导致部分网站缓存失效完全打不开。 有的人发现，即使自己有公网IP，但是仍然无法通过常规方法架设服务器，这是怎么回事呢？这是运营商为了防止个人随意开设各种非法服务，也防止黑客通过扫描器进行抓鸡和批量扫描，将一些常用端口进行了封禁，比如说我们这的中国电信就将 80，8080 等端口封禁了。 这样封禁，虽然一定程度上保证了我们的网络安全，比如说前段时间的勒索病毒正因为国内大部分用户没有独立的公网IP，并且操作系统最容易爆发漏洞的一些，135，139 等端口被运营商封禁了，使得国内个人家庭电脑中招的概率小了很多；但是导致即使有公网 IP，也无法使用常用端口向外网提供服务，只能更换到其他端口。这样有什么不好呢？比较典型的问题就是 WEB 网站默认使用 80 端口，那么在输入网址的时候可以不用带上端口号，显得比较美观。 还有的时候我们在对企业做渗透测试的时候，发现企业某台公网服务器只对公网开放了常见的 80 端口，而我们提权时需要用到的 3389 等端口没有对公网开放，这个时候又该怎么办呢？ 我们如果在自己拥有一台具有公网 IP 服务器的情况下，我们可以借助这台公网 IP 服务器提供转发服务。解决这些问题的方式就是内网穿透了，比较流行的软件比如 Frp，当然如果能进行 UDP 打洞实现 P2P，要比中转快的多（服务器带宽不高的情况下）。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:4:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#为什么要内网穿透"},{"categories":["网络"],"content":" 内网穿透原理先介绍通用方案，先假设我们自己有一台公网服务器，他的 IP 为 45.45.45.45，通过这台服务器建立一个隧道，转发我们的数据请求，有点类似代理。 我们的一台内网服务器 IP 为 10.10.10.10 ，我们现在想把它上的 HTTP 服务通过 45.45.45.45 提供对外访问。 也就是借助公网服务器的网络来发布一个内网服务。 因为公网服务器 IP 是公开的，我们让内网的 10 机器去连接 45 的某个端口，这样 45 和 10 之间建立你一个长连接； 然后当有任何客户端主动连接公网 45 的 80 端口时，公网接收到数据之后通过先前建立好的隧道转发到内网主机 10，内网主机接收到来自隧道的数据包后再主动连接内网主机自身的 80 端口，待 HTTP 服务器程序处理完这个数据包，生成了响应报文之后再原路转发回去，最终到达公网的 80 端口，然后返回给最开始请求公网服务器 80 端口的客户端。 这种原封不动的转发方式通常叫做透明传输或者透明代理。 这种方法基本适用于所有的网络环境，只要你的设备能上互联网，前提是你得拥有一台拥有\"公网IP\"的主机充当\"跳板\"，比较流行的工具有 Frp。 UDP 打洞虽然一般也需要一个 STUN 服务器做探测，以决定使用什么方式穿透，但是建立 P2P 连接后就不需要走服务器流量了，除非是 像一些视频、语音通话，P2P 下载，都可以使用这种方式。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:5:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#内网穿透原理"},{"categories":["网络"],"content":" UDP 打洞UDP Hole Punching（UDP 打洞）原理是当两个位于不同 NAT 后面的客户端想要直接通信时，它们都向一个已知的“打洞服务器”（或协调服务器）发送一个 UDP 包，由协调服务器通知双方对方的 IP 和端口信息。 客户端 A 向打洞服务器发送一个 UDP 包。NAT A 为 A 创建一个临时映射（例如 外A_IP:外A_端口）。 客户端 B 向打洞服务器发送一个 UDP 包。NAT B 为 B 创建一个临时映射（例如 外B_IP:外B_端口）。 打洞服务器将 外A_IP:外A_端口 告知 B，将 外B_IP:外B_端口 告知 A。 此时，A 知道 B 的公共地址，B 知道 A 的公共地址。它们会同时向对方的公共地址发送 UDP 包。 如果 NAT 是 Cone 类型：当 A 的 UDP 包到达 NAT B 时，NAT B 会检查这个包。由于 B 之前已经向外发送过包，NAT B 可能会认为这是一个合法的返回流量，从而允许这个包通过。同理，B 发给 A 的包也能通过 NAT A。这样，两个客户端之间的“洞”就被打通了，可以直接进行 P2P 通信。 适用性： 对 Full Cone NAT、Restricted Cone NAT、Port Restricted Cone NAT 效果很好。 局限性： 无法穿透 Symmetric NAT。因为 Symmetric NAT 每次向不同目的发送包时会使用不同的外部端口。当 A 知道 B 的公共 IP 和端口，并向其发送包时，NAT A 会为这次通信分配一个新的外部端口，这个新端口可能不是 B 的 NAT 所期望的那个端口，从而导致包被丢弃。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:5:1","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#udp-打洞"},{"categories":["网络"],"content":" 穿透防火墙为了安全起见，通常会在网络中加入防火墙，防火墙有入站规则和出站规则。如果不是非常严格的安全管控，通常是不会设置出站规则的，但是入站规则一般都会设置的，比如说外部可以通过80端口传入内网的WEB服务器访问网页，但是不能通过3389端口登陆内网的远程桌面。 而在内网渗透的过程中碰到这种情况，我们也可以借助上面内网传统的方式实现穿透防火墙的入站规则。因为防火墙通常只拦截了入站，没有拦截出站，那么我们可以让内网服务器主动出站（主动连接到黑客的服务器），与黑客自己的服务器打通隧道，最终绕过防火墙连上3389远程桌面。 还有一种情况就是我们已经拿下了内网其中一台并没有做任何防火墙规则的白名单服务器，但是我们想连上内网另一台做了入站规则的目标服务器，那么我们可以让这台白名单服务器作为一个跳板，让他先监听自身任意一个端口，然后在有任何用户连上这个端口之后，白名单服务器就主动连上内网的目标服务器，然后借助这台白名单服务器打通黑客和目标服务器的连接隧道。 而在黑客工具中大名鼎鼎的 lcx 原理也就是如此，前者的实现是 lcx 的 listen 和 slave 命令，后者的实现是lcx的tran命令。 IP 隧道是指一种可在两网络间用网际协议进行通信的通道。在该通道里，会先封装其他网络协议的数据包，之后再传输信息。 在IP隧道中，每个IP包、来源/目的地址信息都被封装在一个数据包中，该数据包用于实际物理网络传递。 因为防火墙的本质及原始数据报文被隐藏了，IP 隧道经常用于绕过简单的防火墙规则，通常需要通过内容控制软件才能对 IP 隧道进行筛查。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:6:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#穿透防火墙"},{"categories":["网络"],"content":" 其他配置如果你拥有公网 IP，下面的 DDNS 和端口映射你大概也需要。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:7:0","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#其他配置"},{"categories":["网络"],"content":" DDNS适用于有公网 IP 的，在路由器的管理界面应该看到过，由于运营商分配的公网 IP 地址不断变动，DDNS的原理就是内网设备（一般是路由器）每隔一段时间对DDNS服务器发起请求，DNS服务器将请求的IP记录下来并且刷新相关域名的解析记录（一般是A记录），这样每次拨号怎么变动 ，域名总是指向路由器所分配的公网IP。 一般DDNS服务都是免费的，常见的路由器里会集成，但是并不好用，推荐 DDNS-GO。 不过让我想到了以前玩远控时候用的动态域名，肉鸡上线后会自动链接这个域名，然后通过 DDNS 就相当于都在链接你的电脑了。 应用：解决很多网络视频服务器和网络摄像机通过远程访问时需要一个固定的 IP，这也是要公网 IP 的最好接口，家里有摄像头需要。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:7:1","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#ddns"},{"categories":["网络"],"content":" 端口映射上面说过一些端口例如 80 运营商的防火墙可能会拦截，并且只通过一个公网 IP 无法确定具体是找你局域网的那台设备，因为这个公网 IP 是你家庭所有设备通过 NAT 共用的； 路由器作为家庭网络的入口，可以在上面配置当有人请求我（公网 IP）的 8000 端口的时候，转发到内网的 192.168.9.1 这台机器的 80 端口上，这个规则就是一条端口映射。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:7:2","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#端口映射"},{"categories":["网络"],"content":" UPnP UPnP (Universal Plug and Play) 是一套网络协议的集合，旨在使网络设备（如电脑、手机、路由器、打印机、智能家电、游戏机等）能够彼此自动发现、互相通信和协同工作，而无需用户进行复杂的配置。 它的核心理念是“即插即用”——设备连接到网络后，能够自动与其他设备和应用程序交互。 简单来说，UPnP 就是让家里的智能设备们能够“说上话”，并且能自动地完成一些网络配置任务。 内网穿透语境中，表示允许局域网内的设备自动请求路由器进行端口映射 (Port Mapping)。 也就是说，内部设备可以向支持 UPnP IGD 的路由器发送指令，告诉路由器“请帮我把外部的某个端口映射到我内部的某个端口和 IP 地址”。 路由器中这个功能默认是关闭的，我也不建议开启，它带来的风险比较大。 ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:7:3","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#upnp"},{"categories":["网络"],"content":" CloudflareTunnels简单安全的暴露自己的 web 服务可以使用 CloudflareTunnels，但是隐藏在 CF 的后面必然会慢一些，国内某些地方的网络也可能不通。 例如 https://www.checkmynat.com 在线探测，小米（stun.miwifi.com:3478）和搜索关键字 public-stun ↩︎ 例如 NatTypeTester、NATMap ↩︎ ","date":"2025-07-28","objectID":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:7:4","series":null,"tags":["内网穿透","NAT"],"title":"理解NAT和内网穿透","uri":"/%E7%90%86%E8%A7%A3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/#cloudflaretunnels"},{"categories":["开发日志"],"content":"如果经常需要在各种开发项目之间切换，而这些项目又各自需要不同的运行环境，尤其是不同的运行时版本或依赖库，那么没有一个环境管理工具就会变得特别混乱。 作为一个主业 Java 方向的，看到 Node.js/Python 的包管理，真的是头大，处理版本问题那是小心翼翼，轻易不敢升级，一不小心就跑不起来了。。。 后来接触到有一些管理软件可以快速切换版本，但是每一种语言装一个还是有点麻烦，毕竟像我这样同时有多个语言环境需求的肯定不在少数，每一个工具都是学习成本； 后来我发现有一种多语言环境管理工具，可以把各个语言统一管理，并且他们之间的配置文件大多能兼容，这个就是我推荐的，放在最后。 ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:0:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#"},{"categories":["开发日志"],"content":" Node.js前端（当然也能做后端了）我只能说发展太快了，我这种非专业的根本追不上，各种新工具层出不穷，JS 的高度灵活性真是能玩出花，node 的各个版本也有一定的差异，官方包管理 npm 也有一些历史问题被人疯狂吐槽，现在我知道的比较出名的代替是： Yarn 并行下载安装，在大型项目中使用更可靠的锁定文件. pnpm 通过内容寻址来去除重复依赖，节省磁盘空间，加速安装. 当然这玩意发展太快，现在又出现了什么新工具我就不了解了。 而 node 版本的管理，我认为比较有名的有这几个： nvm 基于 shell 脚本的 Node.js 版本管理工具，老牌，广为人知和功能全面 n 基于 npm 的 Node.js 版本管理工具，以其简洁的命令行界面和快速的安装、切换速度著称 fnm 基于 Rust 编写的 Node.js 版本管理工具，以其极快的速度和跨平台支持而闻名 这些工具的具体使用方法就不展开说了，基本都差不多，毕竟我觉得现在有了更好的方案。 让我最难受的大概是每个项目依赖都要在当前文件夹安装一遍，嵌套可能还深不见底，Windows 下压缩打包都不一定能打包的了；到现在还能看到开发一个 app 100kb，安装的依赖 10G 的地狱笑话 haha ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#nodejs"},{"categories":["开发日志"],"content":" Python个人感觉它的包管理和 Node.js 的 npm 真的挺类似的，py 官方的包管理是 pip，也经常被吐槽慢，也同样存在依赖库版本兼容问题，并且还有 python2/python3 的兼容问题，虽然现在基本都是 py3 的天下了。 在介绍版本环境控制之前，先介绍两个好用的工具，我使用的是 virtualenv 来做环境管理隔离，如果用的是 fish 的话要用 VirtualFish；而 uv 则是解决 pip 依赖安装速度等问题；再搭配版本管理工具基本就能满足大部分需求了。 VirtualFish 的一些基本使用方法： sh # 创建新环境 vf new name # 激活环境 vf activate name # 退出环境 vf deactivate # 删除环境 vf rm name # 查看环境 vf ls # 启用自动激活 vf auto enable uv 的一些基本使用方法： sh # 安装单个包（比 pip 快的多） uv pip install requests uv pip list uv pip list --outdated # 查看更新包 # 全局生效 uv pip install --system pandas 当然如果是非编程方向，例如数据分析方向，uv 未必合适，可能还是 conda 更合适一些，python 的生态真的太割裂了，conda 也被吐槽的很厉害，或者可以尝试一下 miniconda 或者 pixi VirtualFish 和 uv 这类工具完全可以并且通常推荐和版本管理工具搭配使用，毕竟他们解决的不是一类问题。 ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#python"},{"categories":["开发日志"],"content":" JavaJava 生态我感觉相比之下还是要好得多，maven/gradle 下大部分的库都是可以向下兼容的，从 JDK8 之后 JDK 的向下兼容会差一些，毕竟放弃历史包袱也是为了更快的适应时代潮流。 对于 JDK 版本管理问题，推荐 sdkman，它在 MacOS/Linux 下体验还是不错的，是一个 CLI 工具，可以比较方便的切换、安装不同发行版的 OpenJDK 版本。 也支持安装一些 Java 生态的常用工具，感兴趣的可以看看使用手册。 sh # 安装 cli，查看版本 curl -s \"https://get.sdkman.io\" | bash sdk version # 安装 JDK，默认 tem sdk install java # 指定版本 sdk install scala 3.4.2 # 卸载 sdk uninstall scala 3.4.2 # 搜索查看可安装的发行版 sdk list java # 使用 sdk use scala 3.4.2 sdk default scala 3.4.2 sdk current java ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#java"},{"categories":["开发日志"],"content":" OpenJDK 发行版选择自从 Java8 之后 Oracle 的骚操作，官方版本的 JDK 肯定是不推荐的，能用得起的企业也没多少吧。 主要的发行版有： Oracle OpenJDK Adoptium (Eclipse Temurin) Amazon Corretto Red Hat build of OpenJDK BellSoft Liberica JDK Azul Zulu Alibaba Dragonwell … 其他的华为、腾讯都有自己的发行版，他们这些云计算厂商都是根据自己的平台优化过的，所以除非绑定平台可以尝试，要不然还是用一些通用的吧。 说结论，Liberica JDK 与 AdoptOpenJDK（现已更名为 Eclipse Temurin）可能是最佳的选择。 Liberica 是 Spring 官方推荐的发行版，我了解了下 BellSoft 这家公司，是一家专注于 Java 技术的公司，是 OpenJDK 的主要贡献者之一，根据场景有不同的版本，例如 Lite 版本是容器优化，Standard 日常开发，Full 可以 Fx 等 GUI 的开发。 它家我看还有对 Java App 特别优化的 Linux 容器 Alpaquita，有空我也可以尝试下。 而 Eclipse Temurin 原名 AdoptOpenJDK 就不用说了，Eclipse 社区出品不会有太大问题，优点和缺点都是一个，社区驱动嘛，有舍有得，sdkman 默认的就是 Temurin。 我之前一直使用的是 AdoptOpenJDK，现在打算切换到 Liberica 试试。 ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:1","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#openjdk-发行版选择"},{"categories":["开发日志"],"content":" 通用版本管理推荐上，个人的排序是 mise \u003e vfox \u003e asdf 这一类工具一般都会把版本信息保存在项目目录下的一个配置文件中，这样除了工具可以识别当前环境信息，还可以在项目中共享这些信息，确保团队中的每个人都使用相同的工具版本。 sh # mise exec/x 虽然非常适合运行一次性命令，但激活 mise 会更加方便。 mise exec node@22 -- node -v # mise node@22.14.0 ✓ installed # v22.14.0 mise x python@3.12 -- ./myscript.py # 没有特殊说明，配置仅对当前目录生效 mise use --global node@lts mise ls mise use node@23 pnpm@10 # 仅安装，不激活 mise install node mise cache clear mise ls-remote node # 查看所有可用的插件 mise plugins list-all # 安装插件（比如要使用 node） mise plugins add node # 查看已安装的插件 mise plugins ls # 查看已安装的版本 mise ls node mise ls mise use node@lts # 设置环境变量 mise set NODE_ENV=development # 查看当前配置 mise settings mise 的安装参考文档 mise 兼容 asdf 等环境管理软件的配置，并且因为 mise 的设计灵感源自 asdf，老版本兼容 asdf 的插件系统，但是现在并不推荐；速度比 asdf 快的多。 他们两个的配置文件包括下文的 vfox 都是可以互相识别的。 vfox 和 asdf 差不多，也是通过安装插件来实现各种功能。 sh # 查看所有插件 vfox available # 添加插件 vfox add nodejs # 安装 vfox install nodejs@latest vfox install nodejs@21.5.0 vfox search nodejs # 全局生效 vfox use -g nodejs # 临时 session/当前终端生效 vfox use -s nodejs ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:4:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#通用版本管理"},{"categories":["计算机驯服计划"],"content":"最近想用虚拟机装个 XP/7 怀旧一下老游戏，没想到遇到这么多问题。。。 首先我现在用的是 Win11 系统，除了家庭版，其他都是默认开启 Hyper-V 和 WSL2 的，既然 VM 现在免费了，那么我当然优先考虑使用 VM 来装。 话说现在博通收购 VM 以后，虽然免费了，但是下载是真难下，需要注册个账号，官网现在也乱的很，也许之后慢慢会正常吧，放一个下载地址 安装 VM 的时候默认它会出一个提示，反正意思就是和 Hyper-V 冲突，使用他们的兼容模式，如果没有，那说明你没有开启 Hyper-V。 Hyper-V 是微软的虚拟化平台，也可以说是 Windows 自带的虚拟机，类似 Win7 时代的 Virtual PC，类比 ESXi 和 KVM 这些，本来是给服务器用的。 Hyper-V 它是 type-1 类型，直接在硬件层运行，可以理解为是你电脑上跑了个 Hyper-V 然后它虚拟出来了个 Win11 系统给你用，如果你新建一个虚拟机，那么这个虚拟机和宿主机 Win11 是同级别的，共享硬件，尤其是显卡共享就简单了； 所以 Hyper-V 的性能会比较高；但是同时也有人指出这样宿主机的游戏性能会降低，但是一般人应该感觉不出来。 但是话说回来，Hyper-V 毕竟是微软搞的，如果想虚拟个 Linux 或者其他非 Win 的系统可能就不是那么好用了，易用性也不如 VM。 Hyper-V 我也测试过虚拟个 XP，效果也不是很好，可能微软已经放弃对老系统的支持了吧，并且确实不如 VM 顺手。 VMware Workstation Pro 以及 VirtualBox 这类软件是采用的 VT 虚拟化技术，某些场景下可能是个更好的选择。 VM 现在虽然可以和 Hyper-V 共存，但是我实际使用下来感觉不太行，尤其是虚拟 XP 更是非常的卡。 ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#"},{"categories":["计算机驯服计划"],"content":" 卡顿问题装完 XP 后感觉非常卡顿，声音也断断续续，看了下 Win10 应该还好，Win11 尤其严重； 既然知道了 Hyper-V 的原理，我也有考虑是 VT 和 Hyper-V 的兼容性问题，当然也有人说和 VM 的版本有关系，我换过 VM16、VM15，效果是有的，但是不明显。 于是我决定关闭 Hyper-V 和 WSL，毕竟这俩我用的也不多，非要用还是直接 VM 虚拟一台 Linux 或者直接用家里的 PVE 上的 Ubuntu 吧。 折腾到后来才发现一个问题，Win 下的 Docker 现在是依赖 Hyper-V 的，如果把 Hyper-V 关了就没法用 Docker 了，于是来来回回折腾了好几次。 后来看到有网友说即使是 Win11，与 Docker 的兼容性还是不好，默认都会把数据、镜像啥的塞到 C 盘，性能占用也很大（有老哥说 Hyper-V 虚拟机不限制内存的话默认是有多少吃多少，这个我没有求证） 最后我还是决定关掉 Hyper-V，一来 Hyper-V 虚拟机我确实用着不顺手，即使使用三方 NanaBox 类似的软件管理也还是不习惯，性能对我来说倒是其次的。 Docker 的问题可以虚拟一个 Debian 来搞，或者家里有 PVE 的话这个其实也省了。 ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:1:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#卡顿问题"},{"categories":["计算机驯服计划"],"content":" 关闭 Hyper-V首先我还是建议先去 Win 的安全中心里的防护里把内存隔离关了，我觉得用处不大，可能还影响性能； 听老哥说如果开着防护像国内腾讯、网易的游戏进行作弊扫描的时候也是改不了内存的，有的游戏可能会强制你关掉才能进；亦或者有的防作弊检测还会扫盘，这个真是有点恶心人，题外话了。 另外一个是使用各种安卓模拟器的时候可能也会和 Hyper-V 冲突，所以索性给关掉吧。 检查 VT 状态可以使用 CPU-V 来查看。 找到 控制面板→程序→启用或关闭 Windows 功能，然后关闭 “Hype-V”、“Windows 虚拟机监控程序平台”、“适用于 Linux 的 Windows 子系统” 和 “虚拟机平台” 这几项，然后重启。 这时候再看应该就没有 Hyper-V 选项了，然后右键此电脑→管理→服务和应用程序→服务，往下翻，将如图所示有 Hyper-V 字样的服务全部禁用。 如果效果还是不好，可以打开 PoweShell 执行 shell bcdedit /set hypervisorlaunchtype off 还是不行的话就使用 bat 脚本强制卸载掉 bat Dism /online /disable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL pushd \u0026quot;%~dp0\u0026quot; dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum \u0026gt;hyper-v.txt for /f %%i in (\u0026#39;findstr /i . hyper-v.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /remove-package:\u0026quot;%SystemRoot%\\servicing\\Packages\\%%i\u0026quot; del hyper-v.txt ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:2:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#关闭-hyper-v"},{"categories":["计算机驯服计划"],"content":" 后记关闭 Hyper-V 后，我下载了最新的 VM 进行重装，目前现在一切正常，感觉不到卡顿了，另外我又下载了一个 Debian 的镜像给装到了 VM 里面，并且安装了 Docker 和 Portainer，使用上也没什么问题，暂时就先这样。 如果效果再不好我还打算下个 VirtualBox 来试试的，目前看来是用不上了。 ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:3:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#后记"},{"categories":["运行日志"],"content":"十年前接触到了 Github，当时主要就是为了搭建自己的免费博客(以至于随便起了个中二的 ID ・(´ ー `) · )，以记录学习过程中的心得，当时最火的方案毫无疑问是 Hexo + NexT 主题，上学期间对什么对感兴趣，也有时间去研究，写了不少乱七八糟的东西，虽不说有多少精品，数量上几百篇应该是够的。 虽然最近几年写的东西越来越少，时间精力确实大不如之前，不是没东西可写而是写一篇长文太耗费时间精力了，一些几句话能说明白的也不屑于形成一篇博客，都放在我的 BBS/Memo 里记录存档了。 还有一个关键是文章多了之后 Hexo 编译一次太慢了，NexT 的原作者早就退坑，现在看旧博客 有种年久失修的苍老感。 搭建新博客这个想法已经很久很久了，一直在拖延，这两天有时间搞了一下，其实一旦开了头进入状态了还是很不错的一件事。 新博客使用的是 Hugo，基于 Go 的一个静态网站工具，彻底解决 Hexo 编译慢的问题，当然它的可玩性和资源可能不如 Hexo，毕竟我也过了折腾的年纪。 昨天把旧博客的一些配置迁移到了新项目，目前也算是比较满意了，文章的话现在还不打算迁移过来，等我哪天有空挑一下把有用的搞过来，剩下的就保持原样吧。 ","date":"2025-07-20","objectID":"/%E8%BF%81%E7%A7%BB%E5%85%AC%E5%91%8A/:0:0","series":null,"tags":null,"title":"迁移公告","uri":"/%E8%BF%81%E7%A7%BB%E5%85%AC%E5%91%8A/#"},{"categories":null,"content":" 感觉自己萌萌哒 收集一些自己常用的资源站，不在多而在于精，理想条件下是一个网站解决所有需求，再加几个备用。 并不想做成一个导航。 关于学习资源，奈何囊中羞涩，一些软件的定价过于离谱，基本都转向了订阅制，用学习版也是迫不得已。 根据目前的体验，MacOS 的资源是最简单获取的，Windows 是最难的，一些热门软件 DMCA 太严重了（俄罗斯的网站相对宽松），例如 Navicat、IDM，Android 的资源还可以，iOS 没啥必要，自签也只能解决一小部分。 小提示 本页面可能会包含一些具体的软件和服务，但是主要以综合的资源站为主； 博主自用的软件整理请移步 我的软件清单\u0026军火库，这个系列也会包含一些穷鬼开发者【指可免费使用】开发调试用到的一些可爱的环境提供服务商。 同样缓慢整理中… (•̀ᴗ•́)و ̑̑ 缓慢整理中 也许会忘记也说不定呢. ","date":"2025-07-20","objectID":"/resources/:0:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#"},{"categories":null,"content":" Windows/综合 4 分贝 🎉 可以说是 423 down 完美替代，但是资源不是很全。 佛系软件 Adobe 源头 下载安装推荐使用 Adobe Downloader 或者还可以看看 GenP 这个项目 52pojie cybermania filecr 特殊的一些软件，NavicatPremium 参考这篇大佬的博客； Jetbrains 全家桶优先使用 IPFS，或者使用热心网友制作的 jetbra-free，带 Web GUI 可破插件（插件不成功可使用 plugin-privacy 解决），架设服务器参考这个频道；懒人的福音，一键脚本：irm ckey.run/debug|iex 无论哪一种，源头貌似都是来源始皇的 ja-netfilter，不得不说 NB。 IDM 可以跟随这个发布网站进行更新。 Windows 镜像： 山己几子木 🎉 MSDN 我告诉你 系统库 吻妻 专注 Win7？ 精简版 Windows： Revision 和 Atlasos 现在都采取 AME Wizard 精简方式。Atlasos 还提供了 Windows10 / 11 原版 ISO 下载链接，可直接选择简体中文语言版本下载，免去以往设置中文需要进系统下载中文语言包的繁琐。 所谓的 AME Wizard 就是需要你先安装原本 ISO 镜像并且激活，然后运行他们的软件进行精简，因为直接制作 ISO 分发会被微软起诉。 在系统精简上 Revision 更激进，内存管理也是 Revision 更优秀，但是 Atlasos 使用起来更流畅。 AME Wizard 安装方式对虚拟机使用不太友好，还是 ISO 直接安装方便，虽然这违反了用户协议。。。 这时候就可以尝试 NTDEV 发布的 ISO，安装完即可使用。 Revision Atlasos NTDEV Windows X-Lite 远景论坛分享 可以搭配 Windows Update Blocker 来屏蔽系统更新。 关闭 Windows Defender 可以参考 YourAV ，原理是注册一个假的杀毒软件，WD 自己就关了 ","date":"2025-07-20","objectID":"/resources/:1:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#windows综合"},{"categories":null,"content":" MacOS MacKed 🎉 秋佬的 CoreInject 🎉 appstorrent torrentmac ","date":"2025-07-20","objectID":"/resources/:2:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#macos"},{"categories":null,"content":" 移动端特别推荐，X 优化版 piko，广告跳过 GKD 配合 Shizuku。 ","date":"2025-07-20","objectID":"/resources/:3:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#移动端"},{"categories":null,"content":" 以图搜图之前 Google 的搜图挺好用的，但是感觉从 Lens 之后，准确度不太行 Yandex Bing Saucenao 二刺螈，再放几个备用的 https://trace.moe/ https://3d.iqdb.org/ https://www.iqdb.org/ https://ascii2d.net/ Yandex 目前感觉效果应该是最好的，但是魔法网络环境问题，很可能用不了，所以建议直接使用 ru 的域名，这个除了语言问题搜图是无限制的。 ","date":"2025-07-20","objectID":"/resources/:4:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#以图搜图"},{"categories":null,"content":" AI 相关资源 魔塔社区 ","date":"2025-07-20","objectID":"/resources/:5:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#ai-相关资源"},{"categories":null,"content":" 其他 rutor 俄罗斯，版权 Open 新闻聚合 体验比较好的一个，开源地址 / 在线地址，但是目前体验有点卡顿 LDLive L 站网友提供的免费直播 ","date":"2025-07-20","objectID":"/resources/:6:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#其他"},{"categories":null,"content":" 免费网盘 钛盘 免费好用的临时文件分享服务 萌盘 取文件 Koofr 10G 免费，支持 WebDAV ","date":"2025-07-20","objectID":"/resources/:7:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#免费网盘"},{"categories":["网络"],"content":"首先说明一点，我认为目前对于小白用户，尤其是机场用户，Clash / Mihomo 仍然是最佳选择，上手简单、分流优秀。只要理解了分流、Tun、FakeIP 使用上不是问题。","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":" 更新记录 2025-08-24： 经过一段时间的使用，发现这套分流配置还是有点问题，于是又魔改了一版，之前的配置是从 Clash 继承而来的，现在 Clash 已经没了，Mihomo （ClashMeta）目前还在维护，虽说 Mihomo 可以兼容 Clash，这次更新一版 Mihomo 专有的配置文件吧。 2025-07-26： 截止目前，距离我首次写这篇文章的时候，环境已经发生了比较大的变化，对部分内容进行了重写，原版可以去看旧博客。 由于 clash for windows（CFW） 这个 GUI 的作者退坑，不明真相的吃瓜群众都以为是内核 Clash 跑路了，由于人实在是太多，引起了比较大的影响，这种软件主打就是闷声发大财，动静太大作者可不想被喝茶。 紧接着一系列 Clash 系软件删库或者归档，包括内核 Clash、ClashX、ClashForAndroid、clash-verge、ClashMeta 等等。 目前有一些项目进行了复活，例如 ClashMeta 转生 Mihomo，是个二次开发的内核（为了不再次发生上次的情况，Mihomo 要求下游 GUI 软件名字不得使用 Mihomo）； 目前基于 Mihomo 也有一些不错的项目，例如 Spark、Clash Verge Rev、FlClash、clash nyanpasu、MihomoParty（还未改名，原作者已弃坑，暂不推荐） 首先说明一点，我认为目前对于小白用户，尤其是机场用户，Clash / Mihomo 仍然是最佳选择，上手简单、分流优秀。只要理解了分流、Tun、FakeIP 使用上不是问题。 警告 以我个人的看法，毕竟 Clash 已经没了，Clash 系今后的发展并不明朗，有能力的朋友还是尽量转换到一些新流行的内核项目，例如 Sing-box，但是目前问题比较多，也没有特别成熟的 GUI，我目前当作备用，GUI 的备用可以选择 v2rayN。 Mac 用户有更好的选择，例如 Surge 或者 Loon、Stash 等，囊中羞涩也可以用学习版嘛~ 软路由用户除了 OpenClash 也还有 passwall、homeproxy 可选。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:0:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#"},{"categories":["网络"],"content":" 机场节点最近进行了一场大规模的中转入口打击，并且还没有停止的意思，其中打击方式有很多骚操作，各位自行了解，不确定之后会不会无中转可用，悲。 直连 您的设备直接传输数据到国外的代理服务器，路线图可以表示为 用户 —– 代理服务器 普通中转 从您的设备传输数据到国内的数据中心，再由数据中心发送至国外的代理服务器，线图可以表示为 用户 —– 国内中转机 —— 代理服务器 隧道中转 从您的设备传输数据到国内的数据中心，再由数据中心传输至国外的数据中心，国外的数据中心再将数据发送至代理服务器。 线路图可以表示为 用户 —- 国内中转机 —– 国外中转机 —- 代理服务器 这个应该是目前主流的方式 专线 目前常见的专线有 IPLC 和 IEPL，这种线路一般服务于大型的跨国企业，银行等，特点是延迟低，稳定性高，不受防火墙的审查。缺点是价格特别贵。大部分其实都是噱头，实际并不是。 目前稍微好一些的基本都是全中转，所以很多软件都出了入口、落地节点查询，中转下单靠 TCP 测延迟并没有那么有效果，url-test 才能反应实际连接情况。 所以也就理解为什么中转都是 SS 协议，这个协议抗干扰很弱，但是速度非常快，损耗低，用在中转的环境很合适，甚至可以作为游戏节点，如果你订阅到的协议不是 SS 是 VMess 之类，那大概率就是直连，成本很低。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:1:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#机场节点"},{"categories":["网络"],"content":" 配置模板大部分机场都提供一份默认配置文件，包括一些基本的分流规则，但是我推荐自己写一份，更适合自己。 Tip 这一版配置文件在我的网络环境下有点问题，经常断连并且延迟很高，根据我自己的网络环境，我调整了一版，具体修改请参考本系列的下一篇文章。 Mihomo 可以兼容 Clash 的配置，但是 Mihomo 支持一些特殊的语法，下面我参考了 L 站网友的配置，适用于机场用户： yaml proComm: \u0026proComm type: http udp: true interval: 86400 proxy: DIRECTLY lazy: true health-check: enable: true url: https://cp.cloudflare.com/generate_204 interval: 600 timeout: 5 # 秒 lazy: true expected-status: \"204\" method: HEAD # ⚠️ smux 多路复用：部分机场不支持，如连接失败请注释本段 # 稳定性出现问题，可以尝试切换为 smux4 或禁用 padding。 smux: # smux（连接复用，提升多路复用效率，减少握手） enabled: true # 开启 smux 多路复用 padding: true # 增加随机数据，防探测（推荐开） protocol: smux # 或 smux4 u: \u0026u # **所有订阅组引用** use: - 1.p1 - 2.p2 u_s: \u0026u_s # **主用订阅组引用** use: - 1.p1 # **各种代理提供者（机场）的订阅配置** proxy-providers: 1.p1: url: \"\" path: ./proxy_provider/p1.yaml lazy: true \u003c\u003c: *proComm override: additional-prefix: \"p1 »\" 2.p2: url: \"\" path: ./proxy_provider/p2.yaml \u003c\u003c: *proComm override: additional-prefix: \"p2 »\" # **=============================== 节点信息 ===============================** proxies: - { name: DIRECTLY, type: direct, udp: true } # **=============================== DNS 配置 ===============================** # DNS 解析配置，决定了域名解析方式和缓存策略 dns: enable: true # 启用 DNS 功能 ipv6: true listen: 0.0.0.0:1053 # 监听地址和端口 prefer-h3: false # 如果DNS服务器支持DoH3会优先使用h3，提升性能 respect-rules: true # 让 DNS 解析遵循 Clash 的路由规则 cache-algorithm: arc # 使用性能更优的 ARC 缓存算法 cache-size: 2048 # 限制缓存大小，避免占用过多内存 use-hosts: false # 使用hosts use-system-hosts: false # 使用系统hosts # 启用 Fake-IP 模式，这是强制劫持所有 DNS 请求的关键。 enhanced-mode: fake-ip # 设置增强模式为 fake-ip 模式，提高解析速度和连接性能 fake-ip-range: 198.18.0.1/16 # fake-ip 地址范围 # Fake-IP 过滤器：确保国内域名不被 Fake-IP 转换。 fake-ip-filter-mode: blacklist fake-ip-filter: - \"rule-set:private_domain,cn_domain\" - \"geosite:connectivity-check\" - \"geosite:private\" - \"rule-set:fake_ip_filter_DustinWin\" default-nameserver: - 1.1.1.1 # Cloudflare Public DNS (UDP) - 8.8.8.8 # Google Public DNS (UDP) # - 223.5.5.5 # 阿里（国内） # - 119.29.29.29 # 腾讯（国内） # - system # 系统 DNS (保留以防万一) #`nameserver-policy` 精准分流与严格兜底。** # 确保国内域名走国内 DNS，境外域名走境外 DNS。这是解决问题的关键。 # 这是 Clash 进行主要 DNS 查询时使用的服务器列表。 nameserver: # 默认 DNS，供所有请求使用，支持 DoH3 的在前面 - https://1.1.1.1/dns-query # Cloudflare（支持 H3） - https://dns.google/dns-query # Google（支持 H3） - 1.1.1.1 # Cloudflare Public DNS (UDP) - 8.8.8.8 # Google Public DNS (UDP) # - https://dns.alidns.com/dns-query # 阿里（国内稳定） # - https://doh.pub/dns-query # 腾讯 (境内，DoH，可作为备选) nameserver-policy: \"geosite:cn,private\": # 国内域名和私有域名强制走国内 DNS - https://223.5.5.5/dns-query # 阿里 - https://doh.pub/dns-query # 腾讯 - 223.5.5.5 # 阿里 UDP - 119.29.29.29 # 腾讯 UDP \"geo:cn\": # 也可以用 geo:cn 匹配 IP - https://223.5.5.5/dns-query - https://doh.pub/dns-query - 223.5.5.5 # 阿里 UDP - 119.29.29.29 # 腾讯 UDP \"geosite:gfw\": # 新增：GFW 列表域名强制走国外 DNS - https://1.1.1.1/dns-query - https://dns.google/dns-query - 1.1.1.1 - 8.8.8.8 \"geosite:geolocation-!cn\": # 新增：非中国大陆域名强制走国外 DNS - https://1.1.1.1/dns-query - https://dns.google/dns-query - 1.1.1.1 - 8.8.8.8 \"full-nameserver\": # 新增：最终兜底，所有未匹配的域名查询强制走国外 DNS - https://1.1.1.1/dns-query - https://dns.google/dns-query - 1.1.1.1 - 8.8.8.8 # 当 `nameserver` 中的 DNS 服务器解析失败时，Clash 会尝试这里的 DNS。 fallback: - 1.1.1.1 # Cloudflare DNS备用 - 8.8.8.8 # Google DNS备用 # 用于代理服务器自身的 DNS 解析，仅包含国外 DNS。 proxy-server-nameserver: # 当请求通过代理（即国外站）时使用 - https://1.1.1.1/dns-query # Cloudflare，DoH3 - https://dns.google/dns-query # Google，DoH3 - 1.1.1.1 - 8.8.8.8 # **控制面板** external-controller: 127.0.0.1:9090 secret: \"123465.\" external-ui: \"./ui\" external-ui-url: \"https://github.com/Zephyruso/zashboard/releases/latest/download/dist.zip\" # **=============================== 全局设置 ===============================** # 影响全局网络和系统的配置 # 设置代理监听的端口、系统参数等 # 控制代理如何与系统交互 port: 7890 socks-port: 7891 # SOCKS5 代理端口 redir-port: 7892 # 透明代理端口，用于 Linux 和 MacOS mixed-port: 7893 # HTTP(S) 和 SOCKS 代理混合端口 tproxy-port: 7894 allow-lan: true # 允许局域网连接 mode: rule bind-address: \"*\" # 绑定 IP 地址，仅作用于 allow-lan 为 true，'*'表示所有地址 ipv6: true unified-delay: true # 更换延迟计算方式，去除握手等额外延迟 tcp-concurrent: true # 启用 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:2:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#配置模板"},{"categories":["网络"],"content":" DNS这部分的功能非常实用，虽然最开始我完全看不懂，也不知道什么意思，在这里的配置也让我踩坑了好几次，模板配置中几个不容易理解的地方： DNS相关配置 dns: listen: 0.0.0.0:1053 # 监听地址和端口 # 启用 Fake-IP 模式，这是强制劫持所有 DNS 请求的关键。 enhanced-mode: fake-ip fake-ip-filter-mode: blacklist fake-ip-filter: default-nameserver: nameserver: nameserver-policy: fallback: proxy-server-nameserver: clash DNS 请求逻辑： 当访问一个域名时，nameserver 与 fallback 列表内的所有服务器并发请求，得到域名对应的 IP 地址。 clash 将选取 nameserver 列表内，解析最快的结果。 若解析结果中，IP 地址属于国外，那么 clash 将选择 fallback 列表内，解析最快的结果。 【Mihomo】当配置了 nameserver-policy，会优先使用 nameserver-policy 配置的规则。 geosite 一般是软件内置的基于服务或者地理位置的规则，例如 geosite:cn 包含了所有在中国大陆常用的网站域名，而 geo:cn 是 IP 匹配规则。 因此，在 nameserver 和 fallback 内都放置无污染、解析速度较快的国内 DNS 服务器，以达到最快的解析速度。 但是 fallback 列表内服务器会用在解析境外网站，为了结果绝对无污染，可以使用支持 DoT/DoH 的服务器。 Tip 模板配置中，我在 nameserver、proxy-server-nameserver、default-nameserver 配置了国外的 DNS（防止 DNS 泄露），实际测试中部分中转机场使用国外 DNS 会解析到\"错误的 IP\"，导致速度上不去；并且对于某些国内冷门网站，CDN 匹配效果不好，访问速度也很慢，如果有和我相同的问题，可以把这三个都换成注释的国内 DNS。 fake-ip-filter 的作用就是让一些请求不走 fake-ip，因为有些功能 dns 返回私有 IP 是会有问题的，再说国内的网站也没必要。 特殊的两个：default-nameserver 是默认的 DNS，必须是 IP，用于解析 DNS 服务器的域名；而 proxy-server-nameserver 仅用于解析代理节点的域名，如果不填则遵循 nameserver-policy、nameserver 和 fallback 的配置。 DNS 配置注意事项： 如果您为了确保 DNS 解析结果无污染，请仅保留列表内以 tls:// 或 https:// 开头的 DNS 服务器，但是通常对于国内域名没有必要。 如果您不在乎可能解析到污染的结果，更加追求速度。请将 nameserver 列表的服务器插入至 fallback 列表内，并移除重复项。 fake-ip 一般是要和 dns 配置搭配使用，dns 中我们配置了监听 1053 端口，在 tun 的配置中我们使用 dns-hijack 劫持了原本的 53 的 dns 请求到 dns 模块，也就是将 53 重定向到了 1053，这也是 fake-ip 的基础。 关于 DNS over HTTPS (DoH) 和 DNS over TLS (DoT) 的选择： 对于两项技术双方各执一词，而且会无休止的争论，各有利弊。各位请根据具体需求自行选择，但是配置文件内默认启用 DoT，因为目前国内没有封锁或管制。 DoH: 以 https:// 开头的 DNS 服务器。拥有更好的伪装性，且几乎不可能被运营商或网络管理封锁，但查询效率和安全性可能略低。 DoT: 以 tls:// 开头的 DNS 服务器。拥有更高的安全性和查询效率，但端口有可能被管制或封锁。 这里有个坑，或许是我网络的问题，fallback 中的地址我全部连不上，这就导致一个很严重的后果，国外的网站全部无法命中，甚至 AppStore 都挂了。。。 后面通过调整日志等级到 DEBUG 才知道是 DNS 解析的问题。 除非你所在的地区 DNS 污染特别严重，否则非常不建议使用 fallback，拖慢速度还不稳定，一般的网络情况配置下 nameserver 普通 DNS 足够了，例如阿里的 223.5.5.5。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:3:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#dns"},{"categories":["网络"],"content":" fake-ip下面补充说明下这个 fake-ip 是什么东西； 虽然 Fake IP 这个概念早在 2001 年就被提出来了，但是到 Clash 提供 fake-ip 增强模式以后，依然有很多人对 Fake IP 这个概念以及其作用知之甚少。 参考：https://blog.skk.moe/post/what-happend-to-dns-in-proxy/ 当 TCP 连接建立时，Clash DNS 会直接返回一个保留地址的 IP（即 Fake IP；Clash 默认使用 198.18.0.0/16），同时 Clash 继续解析域名规则和 IP 规则。 PS：开启增强模式后可以尝试 nslookup 看一下解析情况。 由于 TCP/IP 的协议特性，在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。 在不使用代理的情况下，DNS 查询流程想必大家很熟悉了，如果使用了代理，直连模式下以使用 SOCKS5 代理的浏览器为例： 浏览器不再需要从自己的 DNS 缓存中寻找域名对应的 ip，因为已经有了 SOCKS5 代理，浏览器可以直接将域名封装在 SOCKS5 流量之中发往代理客户端（clash） 代理客户端从 SOCKS5 流量中抽出域名并设法获得解析结果 代理客户端将你的 SOCKS5 流量还原成标准的 TCP 请求 代理客户端将这个 TCP 连接建立起来，TCP 连接可以承载的是 HTTPS 传统上，大部分浏览器等应用都会调用系统的内置方法去解析域名，这时候如果你想做一些魔法操作，那么就是在系统这一层上；你可以在本地或者其他地方搭建一个黑魔法 DNS 服务器，然后设置系统的 DNS 为它，就可以实现一些黑魔法效果。 例如，在上面的 2 和 3 之间，可以插入一步：代理客户端使用 某种协议 将浏览器发出的 SOCKS5 的流量重组并发给远端服务器； 远端服务器使用相同的协议还原，然后拿到域名，进行解析；这样就实现了域名在远端进行解析。 这种就是非直连的方式代理，也就是走转发的部分，可以避免本地 DNS 的污染，但是延迟会高一些，各有优劣，各自体会。 然后再说说分流；分流是一个麻烦事。一般情况下，你可能会需要使用域名进行分流（不论是白名单还是黑名单）。不过更多情况下你会使用到基于 IP 的规则来进行分流。 这里可以通过 GUI 的界面来观察连接，如果 TUN 显示一个域名使用了大量端口占用了大量的 ip 池资源，可以考虑将它放到 fake-ip-filter 中不使用 fake-ip。 在域名规则下，如果判断是直连，那么代理客户端没必要进行 DNS 解析，交给原本的流程使用系统接口即可。 在 ip 规则下，当然需要先解析域名，然后匹配规则，但是由于某些协议可以封装域名，因此最终还是会将域名发给远端，由远端进行解析，也就是你本地匹配规则的 ip 与最终代理请求的 ip 可能并不是一个，也避免了影响 CDN 效果。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:3:1","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#fake-ip"},{"categories":["网络"],"content":" 全局流量代理TUN全局流量代理可能会出现在路由器上或者 TUN/TAP 型的支持全局代理客户端上。用户不再主动为每个应用程序设置代理。此时应用程序是不会感知到代理客户端的存在，它们会正常的发起 TCP 连接，Clash 的增强模式或者说 TUN 模式，会接管设备的 TCP 协议栈，并且由于 TCP/IP 协议在拿到 DNS 解析结果之前，连接是不能建立的。 这时候配合上面说的 DNS 解析过程就比较有趣了，前半部分不变，最终会调用系统接口进行解析域名，这时候会向系统配置的 DNS 服务器发起请求； 如果我们在系统的网络设置之中有设置上游 DNS 地址，例如代理客户端可能会修改系统设置中的 DNS 到 127.0.0.1 或者别的内网 IP、也可能保留用户之前的设置，这无所谓，因为… 操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获；这其实就是配置中的 dns-hijack，截获配置的 DNS 服务器的请求。 代理客户端可以将这个解析请求原样发出去、或者用自己的黑魔法，总之都会拿到一个解析结果； 代理客户端将这个解析结果（下面说的 FakeIP 就是返回一个假的内网 IP）返回回去，操作系统拿到了这个解析结果并返回给浏览器 浏览器对这个解析结果的 IP 建立一个 TCP 连接并发送出去，这个 TCP 连接被代理客户端截获。 由于之前代理客户端进行的 DNS 解析请求这一动作，代理客户端可以找到这个只包含目标 IP 的 TCP 连接原来的目标域名； 如果是支持 redir 的代理客户端，那么代理客户端就会直接将域名和 TCP 连接中的其它数据封装成 某种魔法协议 发给远端服务器；或者封装成 SOCKS5 后交给支持 SOCKS5 的代理客户端。 和应用程序直接将流量封装成 SOCKS5 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此除非得到一个 DNS 解析结果，否则 TCP 连接不会建立；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名。 你大概能够发现，浏览器、应用程序直接设置 SOCKS5 代理的话，可以不在代理客户端发起 DNS 解析请求就能将流量发送给远端服务器； 而在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。 有没有办法能像直接设置 SOCKS5 代理一样省掉一次 DNS 解析呢？ 有，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接。 有了 Fake IP，代理客户端无需进行 DNS 解析。最后不论是浏览器、代理客户端还是远端服务器都不会去和 Fake IP 进行连接，因为在代理客户端这里就已经完成了截获、重新封装。 即使按照域名规则分流，代理客户端都没有进行 DNS 解析的需要。只有在遇到了按照 IP 进行分流的规则时，代理客户端才需要进行一次解析拿到一个 IP 用于判断。即便如此，这个 IP 只用于分流规则的匹配，不会被用于实际的连接。 PS：Clash 的增强模式既有 redir-host 也有 Fake IP，目前流行的是 Fake IP 模式。 这里有个很有意思的问题，如果操作系统或者浏览器缓存了 Fake IP，但是代理客户端中 Fake IP 和域名的映射表丢失以后，会出现什么状况？可能会出现什么错误信息？ 你应该大概意识到 Clash 在 Fake IP 模式下偶发的无法上网的原因了。 在使用 Fake-ip 模式后，Application 拿到的是 Clash DNS 返回的 Fake IP，所以也不会出现某些应用程序拒绝连接一些 IP 的情况；和 redir-host 模式一样，在大部分情况下 fake-ip 模式下也可以完全无视 DNS 污染。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:3:2","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#全局流量代理tun"},{"categories":["网络"],"content":" 节点这部分可参考 SS-Rule，写的很好，或者可以看看官方推荐的文档或者 wiki，基本是给自建的人用的，订阅的方式是机场维护。 本次更新（2025-08-24）删掉了示例内容，对订阅用户的意义不大，可参考我的老文章。 订阅模式需要注意的是拉取的不一定只有节点，包括代理组、规则集可能都有，是一份完整的配置；这样就可能面临一个问题，如果你使用远程订阅，并在配置文件内自定义或者修改了一些规则，等配置在下一次更新订阅后可能会丢失； 所以我们自己新建一个配置文件，自定义分流、DNS、等配置部分，节点使用 proxy-providers 引入远程订阅中的节点信息，其他配置会被自己的配置文件覆盖，这是一个很不错的解决方案，我目前就是使用的这种方式来订阅多个机场，并且统一使用我自定义的配置（参考上文的模板配置）。 如果你的机场不提供 clash 订阅连接，可以使用在线服务进行转换，这个一搜一大堆不多说，找个靠谱点的就像，或者自建一个。 顺便提一嘴，如果你没机场只是偶尔临时用，可以看看 proxypool 这个项目，从互联网爬取免费的节点，还有好心人提供了 proxy-providers 的在线地址，可以临时顶一顶，不过毕竟免费风险还是有的，这个自己取舍。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:4:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#节点"},{"categories":["网络"],"content":" 代理组这部分也很重要，配合上门的节点分组，避免一个节点挂掉还得手动换，选择最佳的节点连接。 yaml proxy-groups: # 代理的转发链, 在 proxies 中不应该包含 relay. 不支持 UDP. # 流量: clash \u003c-\u003e http \u003c-\u003e vmess \u003c-\u003e ss1 \u003c-\u003e ss2 \u003c-\u003e 互联网 - name: \"relay\" type: relay proxies: - http - vmess - ss1 # url-test 可以自动选择与指定 URL 测速后，延迟最短的服务器 - name: \"auto\" type: url-test proxies: - ss1 url: 'http://www.gstatic.com/generate_204' interval: 300 - name: \"auto\" type: url-test # 使用订阅节点 use: - provider1 tolerance: 300 # fallback 可以尽量按照用户书写的服务器顺序，在确保服务器可用的情况下，自动选择服务器 - name: \"fallback-auto\" type: fallback proxies: - ss1 url: 'http://cp.cloudflare.com/generate_204' interval: 300 # load-balance 可以使相同 eTLD 请求在同一条代理线路上 - name: \"load-balance\" type: load-balance proxies: - vmess1 url: 'http://www.youtube.com/generate_204' interval: 300 # select 用来允许用户手动选择 代理服务器 或 服务器组 # 您也可以使用 RESTful API 去切换服务器，这种方式推荐在 GUI 中使用 - name: Proxy type: select proxies: - ss1 - vmess1 - auto 这里注意 Proxy 这个关键组，GUI 默认使用这个（其实是后面的规则配的是这个），它的类型是 select 可以允许我们在 GUI 中手动选择一个节点或者组，默认我使用 auto，也就是 url-test 模式的。 如果你在配置文件中设置了 tolerance，Clash 将会计算所有代理服务器的延迟时间，然后以最快的代理服务器的延迟时间为基准，根据 tolerance 的值来筛选其他的代理服务器。只有当一个代理服务器的延迟时间小于基准延迟时间加上 tolerance 时，它才会被选择作为请求的代理服务器，换句话说就是只要在这个范围就不会自动切换，以避免频繁切换带来的体验差。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:5:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#代理组"},{"categories":["网络"],"content":" 规则集简单说就是一组规则的集合，只不过可以在线获取，定时更新，也就是可以直接用别人写好的分流规则，非常爽啊，这里我用过好多，最终选择了 Sukka 大佬的，感觉数量不多，但是够用，很精简。 Mihomo 的分流参考上面的模板配置，Surge 的分流目前还在使用 Sukka 佬的配置。 这里说下 Clash 支持的几种规则； DOMAIN-SUFFIX：域名后缀匹配 DOMAIN：域名匹配 DOMAIN-KEYWORD：域名关键字匹配 IP-CIDR：IP段匹配 SRC-IP-CIDR：源IP段匹配 GEOIP：GEOIP 数据库（国家代码）匹配 DST-PORT：目标端口匹配 SRC-PORT：源端口匹配 PROCESS-NAME：源进程名匹配 RULE-SET：Rule Provider 规则匹配 MATCH：全匹配 写法上面已经有示例了，特别的情况，如果你不想让 Clash 进行 DNS 解析，可以在后面加上 no-resolve。 自带的两种规则是 REJECT 和 DIRECT，很好理解，广告相关的一般直接使用 REJECT，不需要代理的就使用 DIRECT，剩下的就需要指定我们配的代理组，例如本例的 Proxy。 MATCH需要位于规则列表末尾，除了那些漏网之鱼。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:6:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#规则集"},{"categories":["网络"],"content":" 参考规则这里推荐几个开箱即用的规则： ruleset_geodata MetaCubeX官方 clash-rules ios_rule_script GeoIP2-CN ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:7:0","series":["魔法工具箱"],"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#参考规则"},{"categories":null,"content":"这里记录的主要是我个人的笔记，记录我的互联网痕迹 Orz~~； Q：为什么不多贴些截图，不是更直观吗？ A：emmmm 图片太麻烦了，懒 zzz，但是会考虑的。 十年前接触到了 Github，当时主要就是为了搭建自己的免费博客 (以至于随便起了个中二的 ID ・(´ ー `)・)，以记录学习过程中的心得，上学期间对什么对感兴趣，也有时间去研究，写了不少乱七八糟的东西，虽不说有多少精品，数量上几百篇应该是够的。 虽然最近几年写的东西越来越少，时间精力确实大不如之前，不是没东西可写而是写一篇长文太耗费时间精力了，一些几句话能说明白的也不屑于形成一篇博客，都放在我的 BBS / Memo 里记录存档了。 老博客文章多了之后 Hexo 编译一次太慢了，NexT 的原作者也早就退坑，现在看旧博客 有种年久失修的苍老感，之前的旧文章就封存在那里吧，但有的文章也许有翻新焕发第二春的可能 （˶・֊・˶）。 • 爱音乐，爱动漫，爱折腾，爱技术，爱数码，爱科幻 • 希望早日成为大牛。 • 喜欢宅，怕生，克服中… • 二刺螈 Lolicon（三次元熊孩子走开） 新年愿望：过目不忘，不出 bug，系统不崩… 折腾历程： 折腾 Android（一年，果然不擅长前端布局） 折腾 Py、PHP、JS/TS、Go、Linux 等等大杂烩 期间把能知道的技术看了个遍…..额，是简单入门 主攻 Java Web 生态至今（其实就是 Spring 生态、微服务、架构摸索中、DevOps 摸索中） 个人对 JS/ES6 评价很高（学不动了，只能到 ES6 了），对 Vue、React、小程序等生态感兴趣 想要深度学习 Py，对深度学习、LLM/AIGC 之类感兴趣，对图片模式识别和生成尤其感兴趣 慢慢地个人时间越来越少，现在也就折腾下 PVE、Homelab、K3S、NAS，要警惕电子阳痿 总想搞个大新闻 ( ˘•ω•˘ ) ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于我","uri":"/about/#"}]