[{"categories":["运行日志"],"content":"十年前接触到了 Github，当时主要就是为了搭建自己的免费博客(以至于随便起了个中二的 ID ・(´ ー `) · )，以记录学习过程中的心得，当时最火的方案毫无疑问是 Hexo + NexT 主题，上学期间对什么对感兴趣，也有时间去研究，写了不少乱七八糟的东西，虽不说有多少精品，数量上几百篇应该是够的。 虽然最近几年写的东西越来越少，时间精力确实大不如之前，不是没东西可写而是写一篇长文太耗费时间精力了，一些几句话能说明白的也不屑于形成一篇博客，都放在我的 BBS/Memo 里记录存档了。 还有一个关键是文章多了之后 Hexo 编译一次太慢了，NexT 的原作者早就退坑，现在看旧博客 有种年久失修的苍老感。 搭建新博客这个想法已经很久很久了，一直在拖延，这两天有时间搞了一下，其实一旦开了头进入状态了还是很不错的一件事。 新博客使用的是 Hugo，基于 Go 的一个静态网站工具，彻底解决 Hexo 编译慢的问题，当然它的可玩性和资源可能不如 Hexo，毕竟我也过了折腾的年纪。 昨天把旧博客的一些配置迁移到了新项目，目前也算是比较满意了，文章的话现在还不打算迁移过来，等我哪天有空挑一下把有用的搞过来，剩下的就保持原样吧。 ","date":"2025-07-20","objectID":"/%E8%BF%81%E7%A7%BB%E5%85%AC%E5%91%8A/:0:0","series":null,"tags":null,"title":"迁移公告","uri":"/%E8%BF%81%E7%A7%BB%E5%85%AC%E5%91%8A/#"},{"categories":["开发日志"],"content":"如果经常需要在各种开发项目之间切换，而这些项目又各自需要不同的运行环境，尤其是不同的运行时版本或依赖库，那么没有一个环境管理工具就会变得特别混乱。 作为一个主业 Java 方向的，看到 Node.js/Python 的包管理，真的是头大，处理版本问题那是小心翼翼，轻易不敢升级，一不小心就跑不起来了。。。 后来接触到有一些管理软件可以快速切换版本，但是每一种语言装一个还是有点麻烦，毕竟像我这样同时有多个语言环境需求的肯定不在少数，每一个工具都是学习成本； 后来我发现有一种多语言环境管理工具，可以把各个语言统一管理，并且他们之间的配置文件大多能兼容，这个就是我推荐的，放在最后。 ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:0:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#"},{"categories":["开发日志"],"content":" Node.js前端（当然也能做后端了）我只能说发展太快了，我这种非专业的根本追不上，各种新工具层出不穷，JS 的高度灵活性真是能玩出花，node 的各个版本也有一定的差异，官方包管理 npm 也有一些历史问题被人疯狂吐槽，现在我知道的比较出名的代替是： Yarn 并行下载安装，在大型项目中使用更可靠的锁定文件. pnpm 通过内容寻址来去除重复依赖，节省磁盘空间，加速安装. 当然这玩意发展太快，现在又出现了什么新工具我就不了解了。 而 node 版本的管理，我认为比较有名的有这几个： nvm 基于 shell 脚本的 Node.js 版本管理工具，老牌，广为人知和功能全面 n 基于 npm 的 Node.js 版本管理工具，以其简洁的命令行界面和快速的安装、切换速度著称 fnm 基于 Rust 编写的 Node.js 版本管理工具，以其极快的速度和跨平台支持而闻名 这些工具的具体使用方法就不展开说了，基本都差不多，毕竟我觉得现在有了更好的方案。 让我最难受的大概是每个项目依赖都要在当前文件夹安装一遍，嵌套可能还深不见底，Windows 下压缩打包都不一定能打包的了；到现在还能看到开发一个 app 100kb，安装的依赖 10G 的地狱笑话 haha ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#nodejs"},{"categories":["开发日志"],"content":" Python个人感觉它的包管理和 Node.js 的 npm 真的挺类似的，py 官方的包管理是 pip，也经常被吐槽慢，也同样存在依赖库版本兼容问题，并且还有 python2/python3 的兼容问题，虽然现在基本都是 py3 的天下了。 在介绍版本环境控制之前，先介绍两个好用的工具，我使用的是 virtualenv 来做环境管理隔离，如果用的是 fish 的话要用 VirtualFish；而 uv 则是解决 pip 依赖安装速度等问题；再搭配版本管理工具基本就能满足大部分需求了。 VirtualFish 的一些基本使用方法： sh # 创建新环境 vf new name # 激活环境 vf activate name # 退出环境 vf deactivate # 删除环境 vf rm name # 查看环境 vf ls # 启用自动激活 vf auto enable uv 的一些基本使用方法： sh # 安装单个包（比 pip 快的多） uv pip install requests uv pip list uv pip list --outdated # 查看更新包 # 全局生效 uv pip install --system pandas 当然如果是非编程方向，例如数据分析方向，uv 未必合适，可能还是 conda 更合适一些，python 的生态真的太割裂了，conda 也被吐槽的很厉害，或者可以尝试一下 miniconda 或者 pixi VirtualFish 和 uv 这类工具完全可以并且通常推荐和版本管理工具搭配使用，毕竟他们解决的不是一类问题。 ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#python"},{"categories":["开发日志"],"content":" JavaJava 生态我感觉相比之下还是要好得多，maven/gradle 下大部分的库都是可以向下兼容的，从 JDK8 之后 JDK 的向下兼容会差一些，毕竟放弃历史包袱也是为了更快的适应时代潮流。 对于 JDK 版本管理问题，推荐 sdkman，它在 MacOS/Linux 下体验还是不错的，是一个 CLI 工具，可以比较方便的切换、安装不同发行版的 OpenJDK 版本。 也支持安装一些 Java 生态的常用工具，感兴趣的可以看看使用手册。 sh # 安装 cli，查看版本 curl -s \"https://get.sdkman.io\" | bash sdk version # 安装 JDK，默认 tem sdk install java # 指定版本 sdk install scala 3.4.2 # 卸载 sdk uninstall scala 3.4.2 # 搜索查看可安装的发行版 sdk list java # 使用 sdk use scala 3.4.2 sdk default scala 3.4.2 sdk current java ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#java"},{"categories":["开发日志"],"content":" OpenJDK 发行版选择自从 Java8 之后 Oracle 的骚操作，官方版本的 JDK 肯定是不推荐的，能用得起的企业也没多少吧。 主要的发行版有： Oracle OpenJDK Adoptium (Eclipse Temurin) Amazon Corretto Red Hat build of OpenJDK BellSoft Liberica JDK Azul Zulu Alibaba Dragonwell … 其他的华为、腾讯都有自己的发行版，他们这些云计算厂商都是根据自己的平台优化过的，所以除非绑定平台可以尝试，要不然还是用一些通用的吧。 说结论，Liberica JDK 与 AdoptOpenJDK（现已更名为 Eclipse Temurin）可能是最佳的选择。 Liberica 是 Spring 官方推荐的发行版，我了解了下 BellSoft 这家公司，是一家专注于 Java 技术的公司，是 OpenJDK 的主要贡献者之一，根据场景有不同的版本，例如 Lite 版本是容器优化，Standard 日常开发，Full 可以 Fx 等 GUI 的开发。 它家我看还有对 Java App 特别优化的 Linux 容器 Alpaquita，有空我也可以尝试下。 而 Eclipse Temurin 原名 AdoptOpenJDK 就不用说了，Eclipse 社区出品不会有太大问题，优点和缺点都是一个，社区驱动嘛，有舍有得，sdkman 默认的就是 Temurin。 我之前一直使用的是 AdoptOpenJDK，现在打算切换到 Liberica 试试。 ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:1","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#openjdk-发行版选择"},{"categories":["开发日志"],"content":" 通用版本管理推荐上，个人的排序是 mise \u003e vfox \u003e asdf 这一类工具一般都会把版本信息保存在项目目录下的一个配置文件中，这样除了工具可以识别当前环境信息，还可以在项目中共享这些信息，确保团队中的每个人都使用相同的工具版本。 sh # mise exec/x 虽然非常适合运行一次性命令，但激活 mise 会更加方便。 mise exec node@22 -- node -v # mise node@22.14.0 ✓ installed # v22.14.0 mise x python@3.12 -- ./myscript.py # 没有特殊说明，配置仅对当前目录生效 mise use --global node@lts mise ls mise use node@23 pnpm@10 # 仅安装，不激活 mise install node mise cache clear mise ls-remote node # 查看所有可用的插件 mise plugins list-all # 安装插件（比如要使用 node） mise plugins add node # 查看已安装的插件 mise plugins ls # 查看已安装的版本 mise ls node mise ls mise use node@lts # 设置环境变量 mise set NODE_ENV=development # 查看当前配置 mise settings mise 的安装参考文档 mise 兼容 asdf 等环境管理软件的配置，并且因为 mise 的设计灵感源自 asdf，老版本兼容 asdf 的插件系统，但是现在并不推荐；速度比 asdf 快的多。 他们两个的配置文件包括下文的 vfox 都是可以互相识别的。 vfox 和 asdf 差不多，也是通过安装插件来实现各种功能。 sh # 查看所有插件 vfox available # 添加插件 vfox add nodejs # 安装 vfox install nodejs@latest vfox install nodejs@21.5.0 vfox search nodejs # 全局生效 vfox use -g nodejs # 临时 session/当前终端生效 vfox use -s nodejs ","date":"2025-07-25","objectID":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:4:0","series":[],"tags":["Node.js","Python","Java","Tools"],"title":"开发中的环境版本管理工具","uri":"/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#通用版本管理"},{"categories":["计算机"],"content":"最近想用虚拟机装个 XP/7 怀旧一下老游戏，没想到遇到这么多问题。。。 首先我现在用的是 Win11 系统，除了家庭版，其他都是默认开启 Hyper-V 和 WSL2 的，既然 VM 现在免费了，那么我当然优先考虑使用 VM 来装。 话说现在博通收购 VM 以后，虽然免费了，但是下载是真难下，需要注册个账号，官网现在也乱的很，也许之后慢慢会正常吧，放一个下载地址 安装 VM 的时候默认它会出一个提示，反正意思就是和 Hyper-V 冲突，使用他们的兼容模式，如果没有，那说明你没有开启 Hyper-V。 Hyper-V 是微软的虚拟化平台，也可以说是 Windows 自带的虚拟机，类似 Win7 时代的 Virtual PC，类比 ESXi 和 KVM 这些，本来是给服务器用的。 Hyper-V 它是 type-1 类型，直接在硬件层运行，可以理解为是你电脑上跑了个 Hyper-V 然后它虚拟出来了个 Win11 系统给你用，如果你新建一个虚拟机，那么这个虚拟机和宿主机 Win11 是同级别的，共享硬件，尤其是显卡共享就简单了； 所以 Hyper-V 的性能会比较高；但是同时也有人指出这样宿主机的游戏性能会降低，但是一般人应该感觉不出来。 但是话说回来，Hyper-V 毕竟是微软搞的，如果想虚拟个 Linux 或者其他非 Win 的系统可能就不是那么好用了，易用性也不如 VM。 Hyper-V 我也测试过虚拟个 XP，效果也不是很好，可能微软已经放弃对老系统的支持了吧，并且确实不如 VM 顺手。 VMware Workstation Pro 以及 VirtualBox 这类软件是采用的 VT 虚拟化技术，某些场景下可能是个更好的选择。 VM 现在虽然可以和 Hyper-V 共存，但是我实际使用下来感觉不太行，尤其是虚拟 XP 更是非常的卡。 ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#"},{"categories":["计算机"],"content":" 卡顿问题装完 XP 后感觉非常卡顿，声音也断断续续，看了下 Win10 应该还好，Win11 尤其严重； 既然知道了 Hyper-V 的原理，我也有考虑是 VT 和 Hyper-V 的兼容性问题，当然也有人说和 VM 的版本有关系，我换过 VM16、VM15，效果是有的，但是不明显。 于是我决定关闭 Hyper-V 和 WSL，毕竟这俩我用的也不多，非要用还是直接 VM 虚拟一台 Linux 或者直接用家里的 PVE 上的 Ubuntu 吧。 折腾到后来才发现一个问题，Win 下的 Docker 现在是依赖 Hyper-V 的，如果把 Hyper-V 关了就没法用 Docker 了，于是来来回回折腾了好几次。 后来看到有网友说即使是 Win11，与 Docker 的兼容性还是不好，默认都会把数据、镜像啥的塞到 C 盘，性能占用也很大（有老哥说 Hyper-V 虚拟机不限制内存的话默认是有多少吃多少，这个我没有求证） 最后我还是决定关掉 Hyper-V，一来 Hyper-V 虚拟机我确实用着不顺手，即使使用三方 NanaBox 类似的软件管理也还是不习惯，性能对我来说倒是其次的。 Docker 的问题可以虚拟一个 Debian 来搞，或者家里有 PVE 的话这个其实也省了。 ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:1:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#卡顿问题"},{"categories":["计算机"],"content":" 关闭 Hyper-V首先我还是建议先去 Win 的安全中心里的防护里把内存隔离关了，我觉得用处不大，可能还影响性能； 听老哥说如果开着防护像国内腾讯、网易的游戏进行作弊扫描的时候也是改不了内存的，有的游戏可能会强制你关掉才能进；亦或者有的防作弊检测还会扫盘，这个真是有点恶心人，题外话了。 另外一个是使用各种安卓模拟器的时候可能也会和 Hyper-V 冲突，所以索性给关掉吧。 检查 VT 状态可以使用 CPU-V 来查看。 找到 控制面板→程序→启用或关闭 Windows 功能，然后关闭 “Hype-V”、“Windows 虚拟机监控程序平台”、“适用于 Linux 的 Windows 子系统” 和 “虚拟机平台” 这几项，然后重启。 这时候再看应该就没有 Hyper-V 选项了，然后右键此电脑→管理→服务和应用程序→服务，往下翻，将如图所示有 Hyper-V 字样的服务全部禁用。 如果效果还是不好，可以打开 PoweShell 执行 shell bcdedit /set hypervisorlaunchtype off 还是不行的话就使用 bat 脚本强制卸载掉 bat Dism /online /disable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL pushd \u0026quot;%~dp0\u0026quot; dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum \u0026gt;hyper-v.txt for /f %%i in (\u0026#39;findstr /i . hyper-v.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /remove-package:\u0026quot;%SystemRoot%\\servicing\\Packages\\%%i\u0026quot; del hyper-v.txt ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:2:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#关闭-hyper-v"},{"categories":["计算机"],"content":" 后记关闭 Hyper-V 后，我下载了最新的 VM 进行重装，目前现在一切正常，感觉不到卡顿了，另外我又下载了一个 Debian 的镜像给装到了 VM 里面，并且安装了 Docker 和 Portainer，使用上也没什么问题，暂时就先这样。 如果效果再不好我还打算下个 VirtualBox 来试试的，目前看来是用不上了。 ","date":"2025-07-20","objectID":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/:3:0","series":null,"tags":["Windows","虚拟机"],"title":"Win11使用虚拟机遇到的一些问题","uri":"/win11%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA/#后记"},{"categories":null,"content":" 感觉自己萌萌哒 收集一些自己常用的资源站，不在多而在于精，理想条件下是一个网站解决所有需求，再加一个备用。 并不想做成一个导航。 关于学习资源，奈何囊中羞涩，一些软件的定价过于离谱，基本都转向了订阅制，用学习版也是迫不得已。 根据目前的体验，MacOS 的资源是最简单获取的，Windows 是最难的，一些热门软件 DMCA 太严重了（俄罗斯的网站相对宽松），例如 Navicat、IDM，Android 的资源还可以，iOS 没啥必要，自签也只能解决一小部分。 缓慢整理中 也许会忘记也说不定呢. ","date":"2025-07-20","objectID":"/resources/:0:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#"},{"categories":null,"content":" Windows/综合 4 分贝 🎉 可以说是 423 down 完美替代 佛系软件 Adobe 源头 下载安装推荐使用 Adobe Downloader 或者还可以看看 GenP 这个项目 cybermania filecr 特殊的一些软件，NavicatPremium 参考这篇大佬的博客； Jetbrains 全家桶优先使用 IPFS，或者使用热心网友制作的 jetbra-free，带 Web GUI 可破插件（插件不成功可使用 plugin-privacy 解决），架设服务器参考这个频道；无论哪一种，源头貌似都是来源始皇的 ja-netfilter，不得不说 NB。 ","date":"2025-07-20","objectID":"/resources/:1:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#windows综合"},{"categories":null,"content":" MacOS MacKed 🎉 秋佬的 CoreInject 🎉 appstorrent torrentmac ","date":"2025-07-20","objectID":"/resources/:2:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#macos"},{"categories":null,"content":" 移动端特别推荐，X 优化版 piko，广告跳过 GKD 配合 Shizuku。 ","date":"2025-07-20","objectID":"/resources/:3:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#移动端"},{"categories":null,"content":" 其他 rutor 俄罗斯，版权 Open ","date":"2025-07-20","objectID":"/resources/:4:0","series":null,"tags":null,"title":"资源收集","uri":"/resources/#其他"},{"categories":["网络"],"content":"首先说明一点，我认为目前对于小白用户，尤其是机场用户，Clash / Mihomo 仍然是最佳选择，上手简单、分流优秀。只要理解了分流、Tun、FakeIP 使用上不是问题。","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":" 提示 截止目前，距离我首次写这篇文章的时候，环境已经发生了比较大的变化，对部分内容进行了重写，原版可以去看旧博客。 由于 clash for windows（CFW） 这个 GUI 的作者退坑，不明真相的吃瓜群众都以为是内核 Clash 跑路了，由于人实在是太多，引起了比较大的影响，这种软件主打就是闷声发大财，动静太大作者可不想被喝茶。 紧接着一系列 Clash 系软件删库或者归档，包括内核 Clash、ClashX、ClashForAndroid、clash-verge、ClashMeta 等等。 目前有一些项目进行了复活，例如 ClashMeta 转生 Mihomo，是个二次开发的内核（为了不再次发生上次的情况，Mihomo 要求下游 GUI 软件名字不得使用 Mihomo）； 目前基于 Mihomo 也有一些不错的项目，例如 Spark、Clash Verge Rev、FlClash、clash nyanpasu、MihomoParty（还未改名，原作者已弃坑，暂不推荐） 首先说明一点，我认为目前对于小白用户，尤其是机场用户，Clash / Mihomo 仍然是最佳选择，上手简单、分流优秀。只要理解了分流、Tun、FakeIP 使用上不是问题。 警告 以我个人的看法，毕竟 Clash 已经没了，Clash 系今后的发展并不明朗，有能力的朋友还是尽量转换到一些新流行的内核项目，例如 Sing-box，但是目前问题比较多，也没有特别成熟的 GUI，我目前当作备用，GUI 的备用可以选择 v2rayN。 Mac 用户有更好的选择，例如 Surge 或者 Loon、Stash 等，囊中羞涩也可以用学习版嘛~ 软路由用户除了 OpenClash 也还有 passwall、homeproxy 可选。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:0:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#"},{"categories":["网络"],"content":" 机场节点最近进行了一场大规模的中转入口打击，并且还没有停止的意思，其中打击方式有很多骚操作，各位自行了解，不确定之后会不会无中转可用，悲。 直连 您的设备直接传输数据到国外的代理服务器，路线图可以表示为 用户 —– 代理服务器 普通中转 从您的设备传输数据到国内的数据中心，再由数据中心发送至国外的代理服务器，线图可以表示为 用户 —– 国内中转机 —— 代理服务器 隧道中转 从您的设备传输数据到国内的数据中心，再由数据中心传输至国外的数据中心，国外的数据中心再将数据发送至代理服务器。 线路图可以表示为 用户 —- 国内中转机 —– 国外中转机 —- 代理服务器 这个应该是目前主流的方式 专线 目前常见的专线有 IPLC 和 IEPL，这种线路一般服务于大型的跨国企业，银行等，特点是延迟低，稳定性高，不受防火墙的审查。缺点是价格特别贵。大部分其实都是噱头，实际并不是。 目前稍微好一些的基本都是全中转，所以很多软件都出了入口、落地节点查询，中转下单靠 TCP 测延迟并没有那么有效果，url-test 才能反应实际连接情况。 所以也就理解为什么中转都是 SS 协议，这个协议抗干扰很弱，但是速度非常快，损耗低，用在中转的环境很合适，甚至可以作为游戏节点，如果你订阅到的协议不是 SS 是 VMess 之类，那大概率就是直连，成本很低。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:1:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#机场节点"},{"categories":["网络"],"content":" 基本配置大部分机场都提供一份默认配置文件，包括一些基本的分流规则，但是我推荐自己写一份，更适合自己。 Mihomo 和 Clash 配置基本通用的，下面 Clash / Mihomo 称呼都基本一样，主文件 Config.yaml 基本内容： yaml port: 1090 socks-port: 1080 allow-lan: false mode: Rule log-level: info external-controller: 127.0.0.1:9090 secret: 'o4UJC!kwdjainfuaenf' dns: tun: proxies: proxy-groups: proxy-providers: rule-providers: rules: - DOMAIN-SUFFIX,google.com,DIRECT - DOMAIN-KEYWORD,google,DIRECT - DOMAIN,google.com,DIRECT - DOMAIN-SUFFIX,ad.com,REJECT - GEOIP,CN,DIRECT - MATCH,DIRECT 这里特别注意一点，对外控制 API 接口如果用不到就别开，开也设置个复杂密码。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:2:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#基本配置"},{"categories":["网络"],"content":" DNS这部分的功能非常实用，虽然最开始我完全看不懂，也不知道什么意思，在这里的配置也让我踩坑了好几次，首先来看一个示例配置： DNS相关配置 # DNS 服务器配置(可选；若不配置，程序内置的 DNS 服务会被关闭) dns: enable: true listen: 0.0.0.0:53 ipv6: true # 当此选项为 false 时, AAAA 请求将返回空 # 以下填写的 DNS 服务器将会被用来解析 DNS 服务的域名 # 仅填写 DNS 服务器的 IP 地址 default-nameserver: - 223.5.5.5 - 119.29.29.29 - 114.114.114.114 enhanced-mode: fake-ip # 或 redir-host fake-ip-range: 198.18.0.1/16 # Fake IP 地址池 (CIDR 形式) # use-hosts: true # 查询 hosts 并返回 IP 记录 # 在以下列表的域名将不会被解析为 fake ip，这些域名相关的解析请求将会返回它们真实的 IP 地址 fake-ip-filter: # 以下域名列表参考自 vernesong/OpenClash 项目，并由 Hackl0us 整理补充 # === LAN === - '*.lan' # === Linksys Wireless Router === - '*.linksys.com' - '*.linksyssmartwifi.com' # === Apple Software Update Service === - 'swscan.apple.com' - 'mesu.apple.com' # === Windows 10 Connnect Detection === - '*.msftconnecttest.com' - '*.msftncsi.com' # === NTP Service === - 'time.*.com' - 'time.*.gov' - 'time.*.edu.cn' - 'time.*.apple.com' - 'time1.*.com' - 'time2.*.com' - 'time3.*.com' - 'time4.*.com' - 'time5.*.com' - 'time6.*.com' - 'time7.*.com' - 'ntp.*.com' - 'ntp.*.com' - 'ntp1.*.com' - 'ntp2.*.com' - 'ntp3.*.com' - 'ntp4.*.com' - 'ntp5.*.com' - 'ntp6.*.com' - 'ntp7.*.com' - '*.time.edu.cn' - '*.ntp.org.cn' - '+.pool.ntp.org' - 'time1.cloud.tencent.com' # === Music Service === ## NetEase - '+.music.163.com' - '*.126.net' ## Baidu - 'musicapi.taihe.com' - 'music.taihe.com' ## Kugou - 'songsearch.kugou.com' - 'trackercdn.kugou.com' ## Kuwo - '*.kuwo.cn' ## JOOX - 'api-jooxtt.sanook.com' - 'api.joox.com' - 'joox.com' ## QQ - '+.y.qq.com' - '+.music.tc.qq.com' - 'aqqmusic.tc.qq.com' - '+.stream.qqmusic.qq.com' ## Xiami - '*.xiami.com' ## Migu - '+.music.migu.cn' # === Game Service === ## Nintendo Switch - '+.srv.nintendo.net' ## Sony PlayStation - '+.stun.playstation.net' ## Microsoft Xbox - 'xbox.*.microsoft.com' - '+.xboxlive.com' # === Other === ## QQ Quick Login - 'localhost.ptlogin2.qq.com' ## Golang - 'proxy.golang.org' ## STUN Server - 'stun.*.*' - 'stun.*.*.*' - '+.stun.*.*' - '+.stun.*.*.*' - '+.stun.*.*.*.*' - 'heartbeat.belkin.com' - '*.linksys.com' - '*.linksyssmartwifi.com' - '*.router.asus.com' - 'mesu.apple.com' - 'swscan.apple.com' - 'swquery.apple.com' - 'swdownload.apple.com' - 'swcdn.apple.com' - 'swdist.apple.com' - 'lens.l.google.com' - 'stun.l.google.com' - '+.nflxvideo.net' - '*.square-enix.com' - '*.finalfantasyxiv.com' - '*.ffxiv.com' - '*.mcdn.bilivideo.cn' # 支持 UDP / TCP / DoT / DoH 协议的 DNS 服务，可以指明具体的连接端口号。 # 所有 DNS 请求将会直接发送到服务器，不经过任何代理。 # Clash 会使用最先获得的解析记录回复 DNS 请求 nameserver: - https://doh.pub/dns-query - https://dns.alidns.com/dns-query # 当 fallback 参数被配置时, DNS 请求将同时发送至上方 nameserver 列表和下方 fallback 列表中配置的所有 DNS 服务器. # 当解析得到的 IP 地址的地理位置不是 CN 时，clash 将会选用 fallback 中 DNS 服务器的解析结果。 # fallback: # - https://dns.google/dns-query # 如果使用 nameserver 列表中的服务器解析的 IP 地址在下方列表中的子网中，则它们被认为是无效的， # Clash 会选用 fallback 列表中配置 DNS 服务器解析得到的结果。 # # 当 fallback-filter.geoip 为 true 且 IP 地址的地理位置为 CN 时， # Clash 会选用 nameserver 列表中配置 DNS 服务器解析得到的结果。 # # 当 fallback-filter.geoip 为 false, 如果解析结果不在 fallback-filter.ipcidr 范围内， # Clash 总会选用 nameserver 列表中配置 DNS 服务器解析得到的结果。 # # 采取以上逻辑进行域名解析是为了对抗 DNS 投毒攻击。 # fallback-filter: # geoip: false # ipcidr: # - 240.0.0.0/4 # - 0.0.0.0/32 # domain: # - '+.google.com' # - '+.facebook.com' # - '+.youtube.com' tun: enable: true stack: gvisor # 或 system macOS-auto-route: true macOS-auto-detect-interface: true dns-hijack: - tcp://8.8.8.8:53 - tcp://8.8.4.4:53 clash DNS 请求逻辑： 当访问一个域名时，nameserver 与 fallback 列表内的所有服务器并发请求，得到域名对应的 IP 地址。 clash 将选取 nameserver 列表内，解析最快的结果。 若解析结果中，IP 地址属于国外，那么 clash 将选择 fallback 列表内，解析最快的结果。 因此，在 nameserver 和 fallback 内都放置无污染、解析速度较快的国内 DNS 服务器，以达到最快的解析速度。 但是 fallback 列表内服务器会用在解析境外网站，为了结果绝对无污染，尽量使用支持 DoT/DoH 的服务器。 DNS 配置注意事项： 如果您为了确保 DNS 解析结果无污染，请仅保留列表内以 tls:// 或 https:// 开头的 DNS 服务器，但是通常对于国内域名没有必要。 如果您不在乎可能解析到污染的结果，更加追求速度。请将 nameserver 列表的服务器插入至 fallback 列表内，并移除重复项。 关于 DNS over HTTPS (DoH) 和 DNS over TLS (DoT) 的选择： 对于两项技术双方各执一词，而且会无休止的争论，各有利弊。各位请根据具体需求自行选择，但是配置文件内默认启用 DoT，因为目前国内没有封锁或管制。 DoH: 以 https:// 开头的 D","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:3:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#dns"},{"categories":["网络"],"content":" fake-ip下面补充说明下这个 fake-ip 是什么东西； 虽然 Fake IP 这个概念早在 2001 年就被提出来了，但是到 Clash 提供 fake-ip 增强模式以后，依然有很多人对 Fake IP 这个概念以及其作用知之甚少。 参考：https://blog.skk.moe/post/what-happend-to-dns-in-proxy/ 当 TCP 连接建立时，Clash DNS 会直接返回一个保留地址的 IP（即 Fake IP；Clash 默认使用 198.18.0.0/16），同时 Clash 继续解析域名规则和 IP 规则。 PS：开启增强模式后可以尝试 nslookup 看一下解析情况。 由于 TCP/IP 的协议特性，在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。 在不使用代理的情况下，DNS 查询流程想必大家很熟悉了，如果使用了代理，直连模式下以使用 SOCKS5 代理的浏览器为例： 浏览器不再需要从自己的 DNS 缓存中寻找域名对应的 ip，因为已经有了 SOCKS5 代理，浏览器可以直接将域名封装在 SOCKS5 流量之中发往代理客户端（clash） 代理客户端从 SOCKS5 流量中抽出域名并设法获得解析结果 代理客户端将你的 SOCKS5 流量还原成标准的 TCP 请求 代理客户端将这个 TCP 连接建立起来，TCP 连接可以承载的是 HTTPS 传统上，大部分浏览器等应用都会调用系统的内置方法去解析域名，这时候如果你想做一些魔法操作，那么就是在系统这一层上；你可以在本地或者其他地方搭建一个黑魔法 DNS 服务器，然后设置系统的 DNS 为它，就可以实现一些黑魔法效果。 例如，在上面的 2 和 3 之间，可以插入一步：代理客户端使用 某种协议 将浏览器发出的 SOCKS5 的流量重组并发给远端服务器； 远端服务器使用相同的协议还原，然后拿到域名，进行解析；这样就实现了域名在远端进行解析。 这种就是非直连的方式代理，也就是走转发的部分，可以避免本地 DNS 的污染，但是延迟会高一些，各有优劣，各自体会。 然后再说说分流；分流是一个麻烦事。一般情况下，你可能会需要使用域名进行分流（不论是白名单还是黑名单）。不过更多情况下你会使用到基于 IP 的规则来进行分流。 这里可以通过 GUI 的界面来观察连接，如果 TUN 显示一个域名使用了大量端口占用了大量的 ip 池资源，可以考虑将它放到 fake-ip-filter 中不使用 fake-ip。 在域名规则下，如果判断是直连，那么代理客户端没必要进行 DNS 解析，交给原本的流程使用系统接口即可。 在 ip 规则下，当然需要先解析域名，然后匹配规则，但是由于某些协议可以封装域名，因此最终还是会将域名发给远端，由远端进行解析，也就是你本地匹配规则的 ip 与最终代理请求的 ip 可能并不是一个，也避免了影响 CDN 效果。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:3:1","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#fake-ip"},{"categories":["网络"],"content":" 全局流量代理TUN全局流量代理可能会出现在路由器上或者 TUN/TAP 型的支持全局代理客户端上。用户不再主动为每个应用程序设置代理。此时应用程序是不会感知到代理客户端的存在，它们会正常的发起 TCP 连接，Clash 的增强模式或者说 TUN 模式，会接管设备的 TCP 协议栈，并且由于 TCP/IP 协议在拿到 DNS 解析结果之前，连接是不能建立的。 这时候配合上面说的 DNS 解析过程就比较有趣了，前半部分不变，最终会调用系统接口进行解析域名，这时候会向系统配置的 DNS 服务器发起请求； 如果我们在系统的网络设置之中有设置上游 DNS 地址，例如代理客户端可能会修改系统设置中的 DNS 到 127.0.0.1 或者别的内网 IP、也可能保留用户之前的设置，这无所谓，因为… 操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获；这其实就是配置中的 dns-hijack，截获配置的 DNS 服务器的请求。 代理客户端可以将这个解析请求原样发出去、或者用自己的黑魔法，总之都会拿到一个解析结果； 代理客户端将这个解析结果（下面说的 FakeIP 就是返回一个假的内网 IP）返回回去，操作系统拿到了这个解析结果并返回给浏览器 浏览器对这个解析结果的 IP 建立一个 TCP 连接并发送出去，这个 TCP 连接被代理客户端截获。 由于之前代理客户端进行的 DNS 解析请求这一动作，代理客户端可以找到这个只包含目标 IP 的 TCP 连接原来的目标域名； 如果是支持 redir 的代理客户端，那么代理客户端就会直接将域名和 TCP 连接中的其它数据封装成 某种魔法协议 发给远端服务器；或者封装成 SOCKS5 后交给支持 SOCKS5 的代理客户端。 和应用程序直接将流量封装成 SOCKS5 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此除非得到一个 DNS 解析结果，否则 TCP 连接不会建立；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名。 你大概能够发现，浏览器、应用程序直接设置 SOCKS5 代理的话，可以不在代理客户端发起 DNS 解析请求就能将流量发送给远端服务器； 而在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。 有没有办法能像直接设置 SOCKS5 代理一样省掉一次 DNS 解析呢？ 有，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接。 有了 Fake IP，代理客户端无需进行 DNS 解析。最后不论是浏览器、代理客户端还是远端服务器都不会去和 Fake IP 进行连接，因为在代理客户端这里就已经完成了截获、重新封装。 即使按照域名规则分流，代理客户端都没有进行 DNS 解析的需要。只有在遇到了按照 IP 进行分流的规则时，代理客户端才需要进行一次解析拿到一个 IP 用于判断。即便如此，这个 IP 只用于分流规则的匹配，不会被用于实际的连接。 PS：Clash 的增强模式既有 redir-host 也有 Fake IP，目前流行的是 Fake IP 模式。 这里有个很有意思的问题，如果操作系统或者浏览器缓存了 Fake IP，但是代理客户端中 Fake IP 和域名的映射表丢失以后，会出现什么状况？可能会出现什么错误信息？ 你应该大概意识到 Clash 在 Fake IP 模式下偶发的无法上网的原因了。 在使用 Fake-ip 模式后，Application 拿到的是 Clash DNS 返回的 Fake IP，所以也不会出现某些应用程序拒绝连接一些 IP 的情况；和 redir-host 模式一样，在大部分情况下 fake-ip 模式下也可以完全无视 DNS 污染。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:3:2","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#全局流量代理tun"},{"categories":["网络"],"content":" 节点这部分可参考 SS-Rule，写的很好，或者可以看看官方推荐的文档或者 wiki，基本是给自建的人用的，订阅的方式是机场维护。 需要注意的是，在 v1.9 版本后，作者调整了配置的格式（改动很小），下面使用的是最新的个数，详情可以看官方的说明。 节点 proxies 配置 proxies: # shadowsocks # 支持加密方式： # aes-128-gcm aes-192-gcm aes-256-gcm # aes-128-cfb aes-192-cfb aes-256-cfb # aes-128-ctr aes-192-ctr aes-256-ctr # rc4-md5 chacha20 chacha20-ietf xchacha20 # chacha20-ietf-poly1305 xchacha20-ietf-poly1305 - name: \"ss1\" type: ss server: server port: 443 cipher: chacha20-ietf-poly1305 password: \"password\" # udp: true # vmess # 支持加密方式：auto / aes-128-gcm / chacha20-poly1305 / none - name: \"vmess\" type: vmess server: server port: 443 uuid: uuid alterId: 32 cipher: auto # udp: true # tls: true # skip-cert-verify: true # servername: example.com # 优先级高于 wss host # network: ws # ws-opts: # path: /path # headers: # Host: v2ray.com # max-early-data: 2048 # early-data-header-name: Sec-WebSocket-Protocol - name: \"vmess-http\" type: vmess server: server port: 443 uuid: uuid alterId: 32 cipher: auto # udp: true # network: http # http-opts: # # method: \"GET\" # # path: # # - '/' # # - '/video' # # headers: # # Connection: # # - keep-alive - name: vmess-grpc server: server port: 443 type: vmess uuid: uuid alterId: 32 cipher: auto network: grpc tls: true servername: example.com # skip-cert-verify: true grpc-opts: grpc-service-name: \"example\" # socks5 - name: \"socks\" type: socks5 server: server port: 443 # username: username # password: password # tls: true # skip-cert-verify: true # udp: true # http - name: \"http\" type: http server: server port: 443 # username: username # password: password # tls: true # https # skip-cert-verify: true # Trojan - name: \"trojan\" type: trojan server: server port: 443 - name: \"trojan\" type: trojan server: server port: 443 password: yourpsk # udp: true # sni: example.com # aka server name # alpn: # - h2 # - http/1.1 # skip-cert-verify: true - name: trojan-grpc server: server port: 443 type: trojan password: \"example\" network: grpc sni: example.com # skip-cert-verify: true udp: true grpc-opts: grpc-service-name: \"example\" - name: trojan-ws server: server port: 443 type: trojan password: \"example\" network: ws sni: example.com # skip-cert-verify: true udp: true # ws-opts: # path: /path # headers: # Host: example.com 现在我也不太清楚流行什么协议，Trojan 好像很牛逼，vmess 如果效果还是不理想可以切换试试看，我暂时还没用过。 最流行可能还是 vmess，而订阅模式使用 proxy-providers 来定义，体验更好，使用的时候通过 use 关键字。 订阅配置 proxy-groups: - name: Proxy type: url-test use: - provider1 proxy-providers: provider1: type: http # 使用 url 在线订阅 url: \"url\" interval: 3600 path: ./conf/provider1.yaml health-check: enable: true interval: 600 url: http://cp.cloudflare.com/generate_204 test: type: file # 从文件中读取 path: /test.yaml # 可以使用正则来过滤节点 filter: '(香港|台湾|美国).*' health-check: enable: true interval: 36000 url: http://www.gstatic.com/generate_204 使用 proxy-providers 省去了我们自己维护 proxy 节点，直接从在线或者本地文件读取 proxy 节点信息，其他规则还是我们自己定义，顺便提一嘴，如果你没机场只是偶尔临时用，可以看看 proxypool 这个项目，从互联网爬取免费的节点，还有好心人提供了 proxy-providers 的在线地址，可以临时顶一顶，不过毕竟免费风险还是有的，这个自己取舍。 订阅模式需要注意的是拉取的不一定只有节点，包括代理组、规则集可能都有，这样就可能面临一个问题，如果你使用远程订阅，你自定义的一些规则等配置在下一次更新订阅后可能会丢失； 所以自定义配置部分，节点使用 proxy-providers 是一个很不错的解决方案，我目前就是使用的这种方式来订阅多个机场，并且统一使用我自定义的配置，或者也可以尝试使用 Parser 规则解决。 如果你的机场不提供 clash 订阅连接，可以使用在线服务进行转换，这个一搜一大堆不多说，找个靠谱点的就像，或者自建。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:4:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#节点"},{"categories":["网络"],"content":" 代理组这部分也很重要，配合上门的节点分组，避免一个节点挂掉还得手动换，选择最佳的节点连接。 yaml proxy-groups: # 代理的转发链, 在 proxies 中不应该包含 relay. 不支持 UDP. # 流量: clash \u003c-\u003e http \u003c-\u003e vmess \u003c-\u003e ss1 \u003c-\u003e ss2 \u003c-\u003e 互联网 - name: \"relay\" type: relay proxies: - http - vmess - ss1 - ss2 # url-test 可以自动选择与指定 URL 测速后，延迟最短的服务器 - name: \"auto\" type: url-test proxies: - ss1 url: 'http://www.gstatic.com/generate_204' interval: 300 - name: \"auto\" type: url-test # 使用订阅节点 use: - provider1 tolerance: 300 # fallback 可以尽量按照用户书写的服务器顺序，在确保服务器可用的情况下，自动选择服务器 - name: \"fallback-auto\" type: fallback proxies: - ss1 url: 'http://cp.cloudflare.com/generate_204' interval: 300 # load-balance 可以使相同 eTLD 请求在同一条代理线路上 - name: \"load-balance\" type: load-balance proxies: - vmess1 url: 'http://www.youtube.com/generate_204' interval: 300 # select 用来允许用户手动选择 代理服务器 或 服务器组 # 您也可以使用 RESTful API 去切换服务器，这种方式推荐在 GUI 中使用 - name: Proxy type: select proxies: - ss1 - ss2 - vmess1 - auto 这里注意 Proxy 这个关键组，GUI 默认使用这个（其实是后面的规则配的是这个），它的类型是 select 可以允许我们在 GUI 中手动选择一个节点或者组，默认我使用 auto，也就是 url-test 模式的。 如果你在配置文件中设置了 tolerance，Clash 将会计算所有代理服务器的延迟时间，然后以最快的代理服务器的延迟时间为基准，根据 tolerance 的值来筛选其他的代理服务器。只有当一个代理服务器的延迟时间小于基准延迟时间加上 tolerance 时，它才会被选择作为请求的代理服务器，换句话说就是只要在这个范围就不会自动切换，以避免频繁切换带来的体验差。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:5:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#代理组"},{"categories":["网络"],"content":" 规则集简单说就是一组规则的集合，只不过可以在线获取，定时更新，也就是可以直接用别人写好的分流规则，非常爽啊，这里我用过好多，最终选择了 Sukka 大佬的，感觉数量不多，但是够用，很精简。 规则集订阅 rule-providers: reject_non_ip_drop: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/reject-drop.txt path: ./ruleset/reject_non_ip_drop.txt reject_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/reject.txt path: ./ruleset/reject_non_ip.txt reject_domainset: type: http behavior: domain format: text interval: 43200 url: https://ruleset.skk.moe/Clash/domainset/reject.txt path: ./ruleset/reject_domainset.txt reject_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/ip/reject.txt path: ./ruleset/reject_ip.txt sogouinput: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/sogouinput.txt path: ./ruleset/sogouinput.txt stream_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/stream.txt path: ./ruleset/stream_non_ip.txt stream_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/ip/stream.txt path: ./ruleset/stream_ip.txt ai_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/ai.txt path: ./ruleset/ai_non_ip.txt telegram_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/telegram.txt path: ./ruleset/telegram_non_ip.txt telegram_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/ip/telegram.txt path: ./ruleset/telegram_ip.txt apple_cdn: type: http behavior: domain format: text interval: 43200 url: https://ruleset.skk.moe/Clash/domainset/apple_cdn.txt path: ./ruleset/apple_cdn.txt apple_services: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/apple_services.txt path: ./ruleset/apple_services.txt apple_cn_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/apple_cn.txt path: ./ruleset/apple_cn_non_ip.txt lan_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/lan.txt path: ./ruleset/lan_non_ip.txt lan_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/ip/lan.txt path: ./ruleset/lan_ip.txt domestic_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/domestic.txt path: ./ruleset/domestic_non_ip.txt direct_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/direct.txt path: ./ruleset/direct_non_ip.txt global_non_ip: type: http behavior: classical format: text interval: 43200 url: https://ruleset.skk.moe/Clash/non_ip/global.txt path: ./ruleset/global_non_ip.txt domestic_ip: type: http behavior: classical format: text interval: 43200 url: 'https://ruleset.skk.moe/Clash/ip/domestic.txt' path: ./ruleset/domestic_ip.txt spotify: type: http behavior: classical interval: 43200 url: 'https://ghp.ci/https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/Spotify/Spotify.yaml' path: ./ruleset/Spotify.yaml speedtest: type: http behavior: classical interval: 43200 url: https://ghp.ci/https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/Speedtest/Speedtest.yaml path: ./ruleset/Speedtest.yaml 然后配置下最终规则，整个配置就算完成了： 最终规则 rules: # 自定义规则 示例 - DOMAIN-SUFFIX,todesk.com,DIRECT # ---内置规则集--- # \u003e Safari 防跳转 - DOMAIN,app-site-association.cdn-apple.com,REJECT # ban UDP on Youtube - AND,(AND,(DST-PORT,443),(NETWORK,UDP)),(NOT,((GEOSITE,cn))),REJECT # ban National Anti-fraud Center - DOMAIN,prpr.96110.cn.com,DIRECT - DOMAIN-KEYWORD,96110,REJECT - DOMAIN-SUFFIX,gjfzpt.cn,REJECT # \u003e 🆕 拒绝国家反诈中心请求 - DOMAIN-SUFFIX,gjf","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:6:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#规则集"},{"categories":["网络"],"content":" 脚本同样，这也是 Pro 的专有功能，除了全局、直连、规则，还增加了一个更灵活的脚本模式，来应对日益增多的 Rule 规则。但是目前用的人很少，我也没这个需求，暂不关注。 如果有更个性化的节点处理需求，可以尝试使用 parsers。 ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:7:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#脚本"},{"categories":["网络"],"content":" 参考规则这里推荐几个开箱即用的规则： Profiles clash-rules SS-Rule-Snippet GeoIP2-CN ","date":"2021-06-23","objectID":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/:8:0","series":null,"tags":["Clash","Mihomo","Tools"],"title":"Mihomo使用入门","uri":"/mihomo%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#参考规则"},{"categories":null,"content":"这里记录的主要是我个人的笔记，因为记忆力不是很好 Orz~~； • 爱音乐，爱动漫，爱折腾，爱技术，爱数码，爱科幻 • 希望早日成为大牛。 • 喜欢宅，怕生，克服中… • 二刺螈 Lolicon（三次元熊孩子走开） 新年愿望：过目不忘，不出 bug，系统不崩… 学习历程： 折腾 Android（一年，果然不擅长前端布局） 折腾 Py、PHP、JS/TS、Go、Linux 等等大杂烩 期间把能知道的技术看了个遍…..额，是简单入门 主攻 Java Web 生态至今（其实就是 Spring 生态、微服务、架构摸索中、DevOps 摸索中） 个人对 JS/ES6 评价很高（学不动了，只能到 ES6 了），对 Vue、React、小程序等生态感兴趣 想要深度学习 Py，对深度学习、LLM/AIGC 之类感兴趣，对图片模式识别和生成尤其感兴趣 慢慢地个人时间越来越少，现在也就折腾下 PVE、Homelab、K3S、NAS，要警惕电子阳痿 总想搞个大新闻 ( ˘•ω•˘ ) ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于我","uri":"/about/#"}]